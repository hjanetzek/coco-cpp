/*-------------------------------------------------------------------------
ParserGen -- Generation of the Recursive Descent Parser
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
ported to C++ by Csaba Balazs, University of Szeged
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

#include <ctype.h>
#include "ArrayList.h"
#include "ParserGen.h"
#include "Parser.h"
#include "BitArray.h"
#include "Scanner.h"

namespace Coco {

// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

void ParserGen::Indent(int n) {
	for (int i=0; i < n; ++i) fwprintf(gen, L"\t");
}


// AW: use a switch if more than 5 alternatives and none starts with a resolver
bool ParserGen::UseSwitch(Node *p) {
	if (p->typ != Node::alt) return false;
	int nAlts = 0;
	while (p != NULL) {
		++nAlts;
		// must not optimize with switch-statement, if alt uses a resolver expression
		if (p->sub->typ == Node::rslv) return false;
		p = p->down;
	}
	return nAlts > 5;
}


void ParserGen::CopyFramePart(const wchar_t* stop, const bool doOutput) {
	bool ok = tab->CopyFramePart(gen, fram, stop, doOutput);
	if (!ok) {
		errors->Exception(L" -- incomplete or corrupt parser frame file");
	}
}


void ParserGen::CopySourcePart(Position *pos, int indent) {
	// Copy text described by pos from atg to gen
	int ch, i;
	if (pos != NULL) {
		buffer->SetPos(pos->beg); ch = buffer->Read();
		if (tab->emitLines && pos->line) {
			fwprintf(gen, L"\n#line %d \"%ls\"\n", pos->line, tab->srcName);
		}
		Indent(indent);
		while (buffer->GetPos() <= pos->end) {
			while (ch == CR || ch == LF) {  // eol is either CR or CRLF or LF
				fwprintf(gen, L"\n"); Indent(indent);
				if (ch == CR) { ch = buffer->Read(); } // skip CR
				if (ch == LF) { ch = buffer->Read(); } // skip LF
				for (i = 1; i <= pos->col && (ch == ' ' || ch == '\t'); i++) {
					// skip blanks at beginning of line
					ch = buffer->Read();
				}
				if (i <= pos->col) pos->col = i - 1; // heading TABs => not enough blanks
				if (buffer->GetPos() > pos->end) goto Done;
			}
			fwprintf(gen, L"%lc", ch);
			ch = buffer->Read();
		}
		Done:
		if (indent > 0) fwprintf(gen, L"\n");
	}
}


void ParserGen::GenErrorMsg(int errTyp, Symbol *sym) {
	errorNr++;
	const int formatLen = 1000;
	wchar_t format[formatLen];
	coco_swprintf(format, formatLen, L"\t\t\tcase %d: s = coco_string_create(L\"", errorNr);
	coco_string_merge(err, format);
	if (errTyp == tErr) {
		if (sym->name[0] == L'"') {
			coco_swprintf(format, formatLen, L"%ls expected", tab->Escape(sym->name));
			coco_string_merge(err, format);
		} else {
			coco_swprintf(format, formatLen, L"%ls expected", sym->name);
			coco_string_merge(err, format);
		}
	} else if (errTyp == altErr) {
		coco_swprintf(format, formatLen, L"invalid %ls", sym->name);
		coco_string_merge(err, format);
	} else if (errTyp == syncErr) {
		coco_swprintf(format, formatLen, L"this symbol not expected in %ls", sym->name);
		coco_string_merge(err, format);
	}
	coco_swprintf(format, formatLen, L"\"); break;\n");
	coco_string_merge(err, format);
}


int ParserGen::NewCondSet(BitArray *s) {
	for (int i = 1; i < symSet.Count; i++) // skip symSet[0] (reserved for union of SYNC sets)
		if (Sets::Equals(s, symSet[i])) return i;
	symSet.Add(s->Clone());
	return symSet.Count-1;
}


void ParserGen::GenCond(BitArray *s, Node *p) {
	if (p->typ == Node::rslv) CopySourcePart(p->pos, 0);
	else {
		int n = Sets::Elements(s);
		if (n == 0) fwprintf(gen, L"false"); // happens if an ANY set matches no symbol
		else if (n <= maxTerm) {
			for (int i=0; i < tab->terminals.Count; i++) {
				Symbol *sym = tab->terminals[i];
				if ((*s)[sym->n]) {
					fwprintf(gen, L"la->kind == %d", sym->n);
					--n;
					if (n > 0) fwprintf(gen, L" || ");
				}
			}
		} else
			fwprintf(gen, L"StartOf(%d)", NewCondSet(s));
	}
}


void ParserGen::PutCaseLabels(BitArray *s) {
	for (int i=0; i < tab->terminals.Count; i++) {
		Symbol *sym = tab->terminals[i];
		if ((*s)[sym->n]) fwprintf(gen, L"case %d: ", sym->n);
	}
}


void ParserGen::GenCode(Node *p, int indent, BitArray *isChecked) {
	Node *p2;
	BitArray *s1, *s2;
	while (p != NULL) {
		if (p->typ == Node::nt) {
			Indent(indent);
			fwprintf(gen, L"%ls(", p->sym->name);
			CopySourcePart(p->pos, 0);
			fwprintf(gen, L");\n");
		} else if (p->typ == Node::t) {
			Indent(indent);
			// assert: if isChecked[p->sym->n] is true, then isChecked contains only p->sym->n
			if ((*isChecked)[p->sym->n]) fwprintf(gen, L"Get();\n");
			else fwprintf(gen, L"Expect(%d);\n", p->sym->n);
		} if (p->typ == Node::wt) {
			Indent(indent);
			s1 = tab->Expected(p->next, curSy);
			s1->Or(tab->allSyncSets);
			fwprintf(gen, L"ExpectWeak(%d, %d);\n", p->sym->n, NewCondSet(s1));
		} if (p->typ == Node::any) {
			Indent(indent);
			int acc = Sets::Elements(p->set);
			if (tab->terminals.Count == (acc + 1) || (acc > 0 && Sets::Equals(p->set, isChecked))) {
				// either this ANY accepts any terminal (the + 1 = end of file), or exactly what's allowed here
				fwprintf(gen, L"Get();\n");
			} else {
				GenErrorMsg(altErr, curSy);
				if (acc > 0) {
					fwprintf(gen, L"if ("); GenCond(p->set, p); fwprintf(gen, L") Get(); else SynErr(%d);\n", errorNr);
				} else fwprintf(gen, L"SynErr(%d); // ANY node that matches no symbol\n", errorNr);
			}
		} if (p->typ == Node::eps) {    // nothing
		} if (p->typ == Node::rslv) {   // nothing
		} if (p->typ == Node::sem) {
			CopySourcePart(p->pos, indent);
		} if (p->typ == Node::sync) {
			Indent(indent);
			GenErrorMsg(syncErr, curSy);
			s1 = p->set->Clone();
			fwprintf(gen, L"while (!("); GenCond(s1, p); fwprintf(gen, L")) {");
			fwprintf(gen, L"SynErr(%d); Get();", errorNr); fwprintf(gen, L"}\n");
		} if (p->typ == Node::alt) {
			s1 = tab->First(p);
			bool equal = Sets::Equals(s1, isChecked);
			bool useSwitch = UseSwitch(p);
			if (useSwitch) { Indent(indent); fwprintf(gen, L"switch (la->kind) {\n"); }
			p2 = p;
			while (p2 != NULL) {
				s1 = tab->Expected(p2->sub, curSy);
				Indent(indent);
				if (useSwitch) {
					PutCaseLabels(s1); fwprintf(gen, L"{\n");
				} else if (p2 == p) {
					fwprintf(gen, L"if ("); GenCond(s1, p2->sub); fwprintf(gen, L") {\n");
				} else if (p2->down == NULL && equal) { fwprintf(gen, L"} else {\n");
				} else {
					fwprintf(gen, L"} else if (");  GenCond(s1, p2->sub); fwprintf(gen, L") {\n");
				}
				GenCode(p2->sub, indent + 1, s1);
				if (useSwitch) {
					Indent(indent); fwprintf(gen, L"\tbreak;\n");
					Indent(indent); fwprintf(gen, L"}\n");
				}
				p2 = p2->down;
			}
			Indent(indent);
			if (equal) {
				fwprintf(gen, L"}\n");
			} else {
				GenErrorMsg(altErr, curSy);
				if (useSwitch) {
					fwprintf(gen, L"default: SynErr(%d); break;\n", errorNr);
					Indent(indent); fwprintf(gen, L"}\n");
				} else {
					fwprintf(gen, L"} "); fwprintf(gen, L"else SynErr(%d);\n", errorNr);
				}
			}
		} if (p->typ == Node::iter) {
			Indent(indent);
			p2 = p->sub;
			fwprintf(gen, L"while (");
			if (p2->typ == Node::wt) {
				s1 = tab->Expected(p2->next, curSy);
				s2 = tab->Expected(p->next, curSy);
				fwprintf(gen, L"WeakSeparator(%d,%d,%d) ", p2->sym->n, NewCondSet(s1), NewCondSet(s2));
				s1 = new BitArray(tab->terminals.Count);  // for inner structure
				if (p2->up || p2->next == NULL) p2 = NULL; else p2 = p2->next;
			} else {
				s1 = tab->First(p2);
				GenCond(s1, p2);
			}
			fwprintf(gen, L") {\n");
			GenCode(p2, indent + 1, s1);
			Indent(indent); fwprintf(gen, L"}\n");
		} if (p->typ == Node::opt) {
			s1 = tab->First(p->sub);
			Indent(indent);
			fwprintf(gen, L"if ("); GenCond(s1, p->sub); fwprintf(gen, L") {\n");
			GenCode(p->sub, indent + 1, s1);
			Indent(indent); fwprintf(gen, L"}\n");
		}
		if (p->typ != Node::eps && p->typ != Node::sem && p->typ != Node::sync)
			isChecked->SetAll(false);  // = new BitArray(Symbol.terminals.Count);
		if (p->up) break;
		p = p->next;
	}
}


void ParserGen::GenTokensHeader() {
	fwprintf(gen, L"\tenum {\n");

	// tokens
	for (int i=0; i < tab->terminals.Count; i++) {
		Symbol* sym = tab->terminals[i];
		if (!isalpha(sym->name[0])) {
			continue;
		}
		fwprintf(gen , L"\t\t_%ls=%d,\n", sym->name, sym->n);
	}

	// pragmas
	for (int i=0; i < tab->pragmas.Count; i++) {
		Symbol* sym = tab->pragmas[i];
		fwprintf(gen , L"\t\t_%ls=%d,\n", sym->name, sym->n);
	}

	fwprintf(gen, L"\t};\n");
}


void ParserGen::GenCodePragmas() {
	for (int i=0; i < tab->pragmas.Count; i++) {
		Symbol* sym = tab->pragmas[i];
		fwprintf(gen, L"\t\tif (la->kind == %d) {\n", sym->n);
		CopySourcePart(sym->semPos, 4);
		fwprintf(gen, L"\t\t}\n");
	}
}


void ParserGen::GenProductionsHeader() {
	for (int i=0; i < tab->nonterminals.Count; i++) {
		Symbol* sym = tab->nonterminals[i];
		curSy = sym;
		fwprintf(gen, L"\tvoid %ls(", sym->name);
		CopySourcePart(sym->attrPos, 0);
		fwprintf(gen, L");\n");
	}
}

void ParserGen::GenProductions() {
	for (int i=0; i < tab->nonterminals.Count; i++) {
		Symbol* sym = tab->nonterminals[i];
		curSy = sym;
		fwprintf(gen, L"void Parser::%ls(", sym->name);
		CopySourcePart(sym->attrPos, 0);
		fwprintf(gen, L") {\n");
		CopySourcePart(sym->semPos, 2);
		GenCode(sym->graph, 2, new BitArray(tab->terminals.Count));
		fwprintf(gen, L"}\n"); fwprintf(gen, L"\n");
	}
}


void ParserGen::InitSets() {
	fwprintf(gen, L"\tstatic const bool set[%d][%d] = {\n", symSet.Count, tab->terminals.Count+1);

	for (int i=0; i < symSet.Count; i++) {
		BitArray *s = symSet[i];
		fwprintf(gen, L"\t\t{");
		int j = 0;
		for (int k=0; k<tab->terminals.Count; k++) {
			Symbol *sym = tab->terminals[k];
			if ((*s)[sym->n]) fwprintf(gen, L"T,"); else fwprintf(gen, L"x,");
			++j;
			if (j % 4 == 0) fwprintf(gen, L" ");
		}
		if (i == symSet.Count-1) fwprintf(gen, L"x}\n"); else fwprintf(gen, L"x},\n");
	}
	fwprintf(gen, L"\t};\n\n");
}


void ParserGen::WriteParser() {
	// keep copyright in frame when processing coco grammar
	const bool keepCopyright = tab->checkIsCocoAtg();

	int oldPos = buffer->GetPos();  // Pos is modified by CopySourcePart
	symSet.Add(tab->allSyncSets);

	fram = tab->OpenFrameFile(L"Parser.frame");
	if (fram == NULL) {
		errors->Exception(L"-- Cannot open Parser.frame.\n");
	}

	//
	// Header
	//
	gen = tab->OpenGenFile(L"Parser.h");
	if (gen == NULL) {
		errors->Exception(L"-- Cannot generate Parser header\n");
	}

	for (int i=0; i < tab->terminals.Count; i++) {
		Symbol *sym = tab->terminals[i];
		GenErrorMsg(tErr, sym);
	}

	CopyFramePart(L"-->begin", keepCopyright);
	CopyFramePart(L"-->headerdef");

	if (usingPos != NULL) { CopySourcePart(usingPos, 0); fwprintf(gen, L"\n"); }
	CopyFramePart(L"-->namespace_open");
	int nrOfNs = tab->GenNamespaceOpen(gen);

	CopyFramePart(L"-->constantsheader");
	GenTokensHeader();  /* ML 2002/09/07 write the token kinds */
	fwprintf(gen, L"\tstatic const int maxT = %d;\n", tab->terminals.Count-1);
	CopyFramePart(L"-->declarations"); CopySourcePart(tab->semDeclPos, 0);
	CopyFramePart(L"-->productionsheader"); GenProductionsHeader();
	CopyFramePart(L"-->namespace_close");
	tab->GenNamespaceClose(gen, nrOfNs);

	CopyFramePart(L"-->implementation");
	fclose(gen);

	//
	// Source
	//
	gen = tab->OpenGenFile(L"Parser.cpp");
	if (gen == NULL) {
		errors->Exception(L"-- Cannot generate Parser source\n");
	}

	CopyFramePart(L"-->begin", keepCopyright);
	CopyFramePart(L"-->namespace_open");
	nrOfNs = tab->GenNamespaceOpen(gen);

	CopyFramePart(L"-->pragmas"); GenCodePragmas();
	CopyFramePart(L"-->productions"); GenProductions();
	CopyFramePart(L"-->parseRoot");
	fwprintf(gen, L"\t%ls();\n", tab->gramSy->name);
	if (tab->explicitEof) {
		fwprintf(gen, L"\t// let grammar deal with end-of-file expectations\n");
	}
	else {
		fwprintf(gen, L"\tExpect(0); // expect end-of-file automatically added\n");
	}
	CopyFramePart(L"-->constants");
	if (tab->initCodePos) {
		Indent(1);    // indentation of the first line gets lost otherwise
		CopySourcePart(tab->initCodePos, 0);
	}
	CopyFramePart(L"-->initialization"); InitSets();
	CopyFramePart(L"-->destructor");
	if (tab->deinitCodePos) {
		Indent(1);    // indentation of the first line gets lost otherwise
		CopySourcePart(tab->deinitCodePos, 0);
	}
	CopyFramePart(L"-->errors"); fwprintf(gen, L"%ls", err);
	CopyFramePart(L"-->namespace_close");
	tab->GenNamespaceClose(gen, nrOfNs);

	CopyFramePart(L"$$$");
	fclose(gen);
	buffer->SetPos(oldPos);
}


void ParserGen::WriteStatistics() {
	fwprintf(trace, L"\n");
	fwprintf(trace, L"%d terminals\n", tab->terminals.Count);
	fwprintf(trace, L"%d symbols\n", tab->terminals.Count + tab->pragmas.Count +
	                               tab->nonterminals.Count);
	fwprintf(trace, L"%d nodes\n", tab->nodes.Count);
	fwprintf(trace, L"%d sets\n", symSet.Count);
}


ParserGen::ParserGen(Parser *parser)
:
	usingPos(NULL),
	errorNr(-1),
	curSy(NULL),
	fram(NULL),
	gen(NULL),
	err(NULL),
	tab(parser->tab),
	trace(parser->trace),
	errors(parser->errors),
	buffer(parser->scanner->buffer)
{}


ParserGen::~ParserGen() {
	if (usingPos) {
		delete usingPos;
		usingPos = NULL;
	}
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Coco

// ************************************************************************* //
