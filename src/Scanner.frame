/*---------------------------------*- C++ -*---------------------------------*\
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

License
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

About this file
    This is a so-called 'frame' file that contains skeleton code for
    generating a final Scanner/Parser code.

    The '-->TAG' text markers are used to delimit code chunks and typically
    correspond to places where additional information is added by the
    DFA or ParserGen code. These tag must be the first token to appear
    on a line. Any trailing information is ignored.

    All information prior to the first 'begin' text marker is discarded.
    If the grammar contains a '[copy]' .. '[/copy]' section, its contents
    will added instead.
\*---------------------------------------------------------------------------*/
-->begin    // <-- ignore all preliminary text

#ifndef COCO_$PREFIX$SCANNER_H__
#define COCO_$PREFIX$SCANNER_H__

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cwchar>
#include <string>
#include <fstream>
#include <iostream>

#ifdef _WIN32
# if _MSC_VER >= 1400
#  define coco_swprintf swprintf_s
# elif _MSC_VER >= 1300
#  define coco_swprintf _snwprintf
# elif defined (__MINGW32__)        // MINGW has(had) wrong swprintf args
#  define coco_swprintf _snwprintf
# endif
#endif

// assume every other compiler knows swprintf
#ifndef coco_swprintf
# define coco_swprintf swprintf
#endif


-->namespace_open    // <-- open the namespace(s)


// * * * * * * * * * *  Wide Character String Routines * * * * * * * * * * * //

//
// string handling, wide character
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//! Create by copying str
wchar_t* coco_string_create(const wchar_t* str);

//! Create a substring of str starting at index and length characters long
wchar_t* coco_string_create(const wchar_t* str, int index, int length);

//! Create a lowercase string from str
wchar_t* coco_string_create_lower(const wchar_t* str);

//! Create a lowercase substring of str starting at index and length characters long
wchar_t* coco_string_create_lower(const wchar_t* str, int index, int length);

//! Free storage and nullify the argument
inline void coco_string_delete(wchar_t* &str)
{
	delete[] str;
	str = NULL;
}

//! The length of the str, or 0 if the str is NULL
inline int coco_string_length(const wchar_t* str)
{
	return str ? wcslen(str) : 0;
}

//! The length of the str, or 0 if the str is NULL
inline int coco_string_length(const char* str)
{
	return str ? strlen(str) : 0;
}

//! Compare strings, return true if they are equal
inline bool coco_string_equal(const wchar_t* str1, const wchar_t* str2)
{
	return !wcscmp(str1, str2);
}

//! Compare strings, return true if they are equal
inline bool coco_string_equal(const char* str1, const char* str2)
{
	return !strcmp(str1, str2);
}

//! Compare string contents, return true if they are equal
bool  coco_string_equal(const wchar_t* str1, const char* str2);


//! Simple string hashing function
template<class CharT>
inline int coco_string_hash(const CharT* str)
{
	int h = 0;
	if (str)
	{
		while (*str != 0)
		{
			h = (h * 7) ^ *str;
			++str;
		}
	}
	return h < 0 ? -h : h;
}


//
// String conversions
// ~~~~~~~~~~~~~~~~~~

//! Convert wide string to double
inline double coco_string_toDouble(const wchar_t* str)
{
	return str ? wcstod(str, NULL) : 0;
}


//! Convert wide string to long
inline long coco_string_toLong(const wchar_t* str)
{
	return str ? wcstol(str, NULL, 10) : 0;
}


//
// String handling, byte character
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//! Create a byte string by copying str, restricted to 8bit values
std::string coco_stdString(const wchar_t* str);

//! Create a byte substring of str starting at index and length characters long
//! Restricted to 8bit values
std::string coco_stdString(const wchar_t* str, int index, int length);


//! Create a UTF8 byte string by copying str
std::string coco_stdStringUTF8(const wchar_t* str);

//! Create a UTF8 byte substring starting at index and length characters long
std::string coco_stdStringUTF8(const wchar_t* str, int index, int length);

// * * * * * * * * * End of Wide Character String Routines * * * * * * * * * //


//! Scanner Token
class Token
{
public:
	int kind;       //!< token kind
	int pos;        //!< token position in the source text (starting at 0)
	int col;        //!< token column (starting at 1)
	int line;       //!< token line (starting at 1)
	wchar_t* val;   //!< token value
	Token *next;    //!< Peek tokens are kept in linked list

	Token();        //!< Construct null
	~Token();       //!< Destructor - cleanup allocated val??
};


//! Scanner Buffer
//
//! This Buffer supports the following cases:
//! -# seekable stream (file)
//!    -# whole stream in buffer
//!    -# part of stream in buffer
//! -# non seekable stream (network, console)
class Buffer
{
private:
	unsigned char *buf; //!< input buffer
	int bufCapacity;    //!< capacity of buf
	int bufLen;         //!< length of buffer
	int bufPos;         //!< current position in buffer
	int bufStart;       //!< position of first byte in buffer relative to input stream
	int fileLen;        //!< length of input stream (may change if the stream is no file)
	FILE* cStream;      //!< input stdio stream (normally seekable)
	std::istream* stdStream;  //!< STL std stream (seekable)
	bool isUserStream_;  //!< was the stream opened by the user?

	int ReadNextStreamChunk();
	bool CanSeek() const; //!< true if stream can be seeked otherwise false

protected:
	Buffer(Buffer*);    //!< for the UTF8Buffer

public:
	//! max unicode characters is 0xFFFF (16bit storage)
	static const int MaxChar = 65535;
	static const int EoF = MaxChar + 1;

	//! @brief Attach buffer to a stdio stream.
	//! User streams are not closed in the destructor
	Buffer(FILE*, bool isUserStream = true);

	//! @brief Attach buffer to an STL standard stream
	//! User streams are not closed in the destructor
	explicit Buffer(std::istream*, bool isUserStream = true);

	//! Copy buffer contents from constant character string
	Buffer(const char* chars, int len);

	//! Copy buffer contents from constant character string
	Buffer(const unsigned char* chars, int len);

	//! Close stream (but not user streams) and free buf (if any)
	virtual ~Buffer();

	virtual void Close();   //!< Close stream (but not user streams)
	virtual int Read();     //!< Get character from stream or buffer
	virtual int Peek();     //!< Peek character from stream or buffer

	virtual int GetPos() const;
	virtual void SetPos(int value);
	virtual bool isUTF8() const;  //!< Return false - buffer is not UTF8
};


//! A Scanner buffer that handles UTF-8 characters
class UTF8Buffer : public Buffer
{
public:
	UTF8Buffer(Buffer* b) : Buffer(b) {}
	virtual int Read();
	virtual bool isUTF8() const;  //!< Return true - buffer is UTF8
};


//------------------------------------------------------------------------------
// StartStates
//------------------------------------------------------------------------------
//! maps characters (integers) to start states of tokens
class StartStates
{
	struct Elem
	{
		int key, val;
		Elem *next;

		Elem(int k, int v)
		:
			key(k), val(v), next(0)
		{}
	};

	Elem **table_;

public:
	StartStates()
	:
		table_(new Elem*[128])
	{
		memset(table_, 0, 128*sizeof(Elem*));
	}

	virtual ~StartStates()
	{
		for (int i = 0; i < 128; ++i)
		{
			Elem *e = table_[i];
			while (e)
			{
				Elem *next = e->next;
				delete e;
				e = next;
			}
		}
		delete[] table_;
	}

	void set(int key, int val)
	{
		const int k = unsigned(key) % 128;
		Elem *e = new Elem(key, val);
		e->next = table_[k];
		table_[k] = e;
	}

	int state(int key)
	{
		Elem *e = table_[unsigned(key) % 128];
		while (e && e->key != key) e = e->next;
		return e ? e->val : 0;
	}
};


//------------------------------------------------------------------------------
// KeywordMap
//------------------------------------------------------------------------------
//! maps strings to integers (identifiers to keyword kinds)
class KeywordMap
{
	struct Elem
	{
		wchar_t *key;
		int val;
		Elem *next;

		Elem(const wchar_t *k, int v)
		:
			key(coco_string_create(k)), val(v), next(0)
		{}

		virtual ~Elem()
		{
			coco_string_delete(key);
		}
	};

	Elem **table_;

public:
	KeywordMap()
	:
		table_(new Elem*[128])
	{
		memset(table_, 0, 128*sizeof(Elem*));
	}

	virtual ~KeywordMap()
	{
		for (int i = 0; i < 128; ++i)
		{
			Elem *e = table_[i];
			while (e)
			{
				Elem *next = e->next;
				delete e;
				e = next;
			}
		}
		delete[] table_;
	}

	void set(const wchar_t *key, int val)
	{
		const int k = coco_string_hash(key) % 128;
		Elem *e = new Elem(key, val);
		e->next = table_[k];
		table_[k] = e;
	}

	int get(const wchar_t *key, int defaultVal)
	{
		Elem *e = table_[coco_string_hash(key) % 128];
		while (e && !coco_string_equal(e->key, key)) e = e->next;
		return e ? e->val : defaultVal;
	}
};


//! A Coco/R Scanner
class Scanner
{
private:
-->constantsheader   // <-- add in maxT and noSym
	static const int eofSym = 0;    //!< end-of-file token id
	static const char EOL = '\n';   //!< end-of-line character

	void *firstHeap;  //!< the start of the heap management
	void *heap;       //!< the currently active block
	void *heapTop;    //!< the top of the heap
	void **heapEnd;   //!< the end of the last heap block

	StartStates start;   //!< A map of start states for particular characters
	KeywordMap keywords; //!< A hash of keyword literals to token kind

	Token *t;         //!< current token
	wchar_t *tval;    //!< text of current token
	int tvalLength;   //!< maximum capacity (length) for tval
	int tlen;         //!< length of tval

	Token *tokens;    //!< list of tokens already peeked (first token is a dummy)
	Token *pt;        //!< current peek token

	int ch;           //!< current input character
-->casing0    // <-- add declaration for valCh (when ignoring case)
	int pos;          //!< byte position of current character
	int line;         //!< line number of current character
	int col;          //!< column number of current character
	int oldEols;      //!< the number of EOLs that appeared in a comment

	void CreateHeapBlock();       //!< add a heap block, freeing unused ones
	Token* CreateToken();         //!< fit token on the heap
	void AppendVal(Token* tok);   //!< adjust tok->val to point to the heap and copy tval into it

	void Init();      //!< complete the initialization for the constructors
	void NextCh();    //!< get the next input character into ch
	void AddCh();     //!< append the character ch to tval
-->commentsheader    // <-- declare the comment handlers
	Token* NextToken();  //!< get the next token

public:
	//! The scanner buffer
	Buffer *buffer;

	//! Attach scanner to an existing open file handle
	Scanner(FILE*);

	//! Attach scanner to an existing open STL standard stream
	explicit Scanner(std::istream&);

	//! Open a file for reading and attach scanner
	explicit Scanner(const std::string& fileName);

#ifdef _WIN32
	//! Open a file for reading and attach scanner - Windows only
	explicit Scanner(const std::wstring& fileName);
#endif

	//! Attach scanner to an existing character buffer
	Scanner(const unsigned char* chars, int len);

	//! Attach scanner to an existing character buffer
	Scanner(const char* chars, int len);

	~Scanner();        //!< free heap and allocated memory
	Token* Scan();     //!< get the next token (possibly a token already seen during peeking)
	Token* Peek();     //!< peek for the next token, ignore pragmas
	void ResetPeek();  //!< ensure that peeking starts at the current scan position

	int  Line() const;     //!< Return the current line
	void Line(int lineNo); //!< Define the starting line for reporting errors

}; // end Scanner

-->namespace_close    // <-- close the namespace(s)

#endif // COCO_$PREFIX$SCANNER_H__

// ************************************************************************* //
-->implementation    // <-- start the implementation itself

#include <sstream>

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#include <climits>

#include "$PREFIX$Scanner.h"

// values for the file stream buffering
#define MIN_BUFFER_LENGTH 1024        // 1KB
#define MAX_BUFFER_LENGTH (64*MIN_BUFFER_LENGTH)   // 64KB
// value for the heap management
#define HEAP_BLOCK_SIZE   (64*1024)   // 64KB


-->namespace_open    // <-- open the namespace(s)

// * * * * * * * * * *  Wide Character String Routines * * * * * * * * * * * //

// string handling, wide character

wchar_t* coco_string_create(const wchar_t* str)
{
	const int len = coco_string_length(str);
	wchar_t* dest = new wchar_t[len + 1];
	if (len)
	{
		wcsncpy(dest, str, len);
	}
	dest[len] = 0;
	return dest;
}


wchar_t* coco_string_create(const wchar_t* str, int index, int length)
{
	const int len = (str && *str) ? length : 0;
	wchar_t* dest = new wchar_t[len + 1];
	if (len)
	{
		wcsncpy(dest, &(str[index]), len);
	}
	dest[len] = 0;
	return dest;
}


wchar_t* coco_string_create_lower(const wchar_t* str)
{
	return str ? coco_string_create_lower(str, 0, wcslen(str)) : NULL;
}


wchar_t* coco_string_create_lower(const wchar_t* str, int index, int len)
{
	if (!str) { return NULL; }
	wchar_t* dest = new wchar_t[len + 1];

	for (int i = 0; i < len; ++i)
	{
		const wchar_t ch = str[index + i];
		if (ch >= 'A' && ch <= 'Z')
		{
			dest[i] = ch + ('a' - 'A');   // lower-case
		}
		else
		{
			dest[i] = ch;
		}
	}
	dest[len] = '\0';
	return dest;
}


bool coco_string_equal(const wchar_t* str1, const char* str2)
{
	const int str1Len = coco_string_length(str1);
	const int str2Len = coco_string_length(str2);

	if (str1Len != str2Len)
	{
		return false;
	}

	for (int i = 0; i < str1Len; ++i)
	{
		if (str1[i] != wchar_t(str2[i]))
		{
			return false;
		}
	}

	return true;
}


//
// string handling, byte character
//

std::string coco_stdString(const wchar_t* str)
{
    return str ? coco_stdString(str, 0, wcslen(str)) : std::string();
}


std::string coco_stdString
(
    const wchar_t* str,
    int index,
    int length
)
{
    const int len = (str && *str) ? length : 0;
    std::string dest;
    dest.reserve(len);

    for (int i = 0; i < len; ++i)
    {
        dest += char(str[index+i] & 0xFF);
    }

    return dest;
}


std::string coco_stdStringUTF8(const wchar_t* str)
{
    return str ? coco_stdStringUTF8(str, 0, wcslen(str)) : std::string();
}


std::string coco_stdStringUTF8
(
    const wchar_t* str,
    int index,
    int length
)
{
    const int len = (str && *str) ? length : 0;
    std::string dest;
    dest.reserve(len);


    for (int i = 0; i < len; ++i)
    {
        wchar_t wc = str[index+i];

        if (!(wc & ~0x0000007F))
        {
            // 0x00000000 - 0x0000007F [min. 8bit storage, 1-byte encoding)
            // 0aaaaaaa
            dest += char(wc);
        }
        else if (!(wc & ~0x000007FF))
        {
            // 0x00000080 - 0x000007FF [min. 16bit storage, 2-byte encoding]
            // 110bbbaa 10aaaaaa
            dest += char(0xC0 | ((wc >> 6) & 0x1F));
            dest += char(0x80 | ((wc) & 0x3F));
        }
        else if (!(wc & ~0x0000FFFF))
        {
            // 0x00000800 - 0x0000FFFF [min. 16bit storage, 3-byte encoding]
            // 1110bbbb 10bbbbaa 10aaaaaa
            dest += char(0xE0 | ((wc >> 12) & 0x0F));
            dest += char(0x80 | ((wc >> 6) & 0x3F));
            dest += char(0x80 | ((wc) & 0x3F));
        }
        else if (!(wc & ~0x001FFFFF))
        {
            // 0x00010000 - 0x001FFFFF [min. 24bit storage, 4-byte encoding]
            // 11110ccc 10ccbbbb 10bbbbaa 10aaaaaa
            dest += char(0xF0 | ((wc >> 18) & 0x07));
            dest += char(0x80 | ((wc >> 12) & 0x3F));
            dest += char(0x80 | ((wc >> 6) & 0x3F));
            dest += char(0x80 | ((wc) & 0x3F));
        }
//
// Not (yet) used - wchar_t storage is limited to 16bit on windows
// This also corresponds to the unicode BMP (Basic Multilingual Plane)
//
//        else if (!(wc & ~0x03FFFFFF))
//        {
//            // 0x00200000 - 0x03FFFFFF [min. 32bit storage, 5-byte encoding]
//            // 111110dd 10cccccc 10ccbbbb 10bbbbaa 10aaaaaa
//            dest += char(0xF8 | ((wc >> 24) & 0x03));
//            dest += char(0x80 | ((wc >> 18) & 0x3F));
//            dest += char(0x80 | ((wc >> 12) & 0x3F));
//            dest += char(0x80 | ((wc >> 6) & 0x3F));
//            dest += char(0x80 | ((wc) & 0x3F));
//        }
//        else if (!(wc & ~0x7FFFFFFF))
//        {
//            // 0x04000000 - 0x7FFFFFFF [min. 32bit storage, 6-byte encoding]
//            // 1111110d 10dddddd 10cccccc 10ccbbbb 10bbbbaa 10aaaaaa
//            dest += char(0xFC | ((wc >> 30) & 0x01));
//            dest += char(0x80 | ((wc >> 24) & 0x3F));
//            dest += char(0x80 | ((wc >> 18) & 0x3F));
//            dest += char(0x80 | ((wc >> 12) & 0x3F));
//            dest += char(0x80 | ((wc >> 6) & 0x3F));
//            dest += char(0x80 | ((wc) & 0x3F));
//        }
//
        else
        {
            // report anything unknown/invalid as replacement character U+FFFD
            dest += char(0xEF);
            dest += char(0xBF);
            dest += char(0xBD);
        }
    }

    return dest;
}


// * * * * * * * * * End of Wide Character String Routines * * * * * * * * * //

Token::Token()
:
    kind(0),
    pos(0),
    col(0),
    line(0),
    val(NULL),
    next(NULL)
{}


// Note: this delete may not be correct if the token was actually
// allocated by the internal heap mechanism
Token::~Token()
{
	coco_string_delete(val);
}


// ----------------------------------------------------------------------------
// Buffer Implementation
// ----------------------------------------------------------------------------

Buffer::Buffer(Buffer* b)
:
	buf(b->buf),
	bufCapacity(b->bufCapacity),
	bufLen(b->bufLen),
	bufPos(b->bufPos),
	bufStart(b->bufStart),
	fileLen(b->fileLen),
	cStream(b->cStream),
	stdStream(b->stdStream),
	isUserStream_(b->isUserStream_)
{
	// avoid accidental deletion on any of these members
	b->buf = NULL;
	b->cStream = NULL;
	b->stdStream = NULL;
}


Buffer::Buffer(FILE* istr, bool isUserStream)
:
	buf(NULL),
	bufCapacity(0),
	bufLen(0),
	bufPos(0),
	bufStart(0),
	fileLen(0),
	cStream(istr),
	stdStream(NULL),
	isUserStream_(isUserStream)
{
// ensure binary read on windows
#if _MSC_VER >= 1300
	_setmode(_fileno(cStream), _O_BINARY);
#endif

	if (CanSeek())
	{
		fseek(cStream, 0, SEEK_END);
		fileLen = ftell(cStream);
		fseek(cStream, 0, SEEK_SET);
		bufLen = (fileLen < MAX_BUFFER_LENGTH) ? fileLen : MAX_BUFFER_LENGTH;
		bufStart = INT_MAX; // nothing in the buffer so far
	}

	bufCapacity = (bufLen > 0) ? bufLen : MIN_BUFFER_LENGTH;
	buf = new unsigned char[bufCapacity];
	if (fileLen > 0) SetPos(0);          // setup buffer to position 0 (start)
	else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
	if (bufLen == fileLen && CanSeek()) Close();
}


Buffer::Buffer(std::istream* istr, bool isUserStream)
:
	buf(NULL),
	bufCapacity(0),
	bufLen(0),
	bufPos(0),
	bufStart(0),
	fileLen(0),
	cStream(NULL),
	stdStream(istr),
	isUserStream_(isUserStream)
{
	// ensure binary read on windows
#if _MSC_VER >= 1300
	// TODO
#endif
}


Buffer::Buffer(const char* chars, int len)
:
	buf(new unsigned char[len]),
	bufCapacity(len),
	bufLen(len),
	bufPos(0),
	bufStart(0),
	fileLen(len),
	cStream(NULL),
	stdStream(NULL),
	isUserStream_(false)
{
	memcpy(this->buf, chars, len*sizeof(char));
}


Buffer::Buffer(const unsigned char* chars, int len)
:
	buf(new unsigned char[len]),
	bufCapacity(len),
	bufLen(len),
	bufPos(0),
	bufStart(0),
	fileLen(len),
	cStream(NULL),
	stdStream(NULL),
	isUserStream_(false)
{
	memcpy(this->buf, chars, len*sizeof(char));
}


Buffer::~Buffer()
{
	Close();
	if (buf)
	{
		delete[] buf;
		buf = NULL;
	}
}


void Buffer::Close()
{
	if (!isUserStream_)
	{
		if (cStream)
		{
			fclose(cStream);
			cStream = NULL;
		}
		else if (stdStream)
		{
			delete stdStream;
			stdStream = 0;
		}
	}
}


int Buffer::Read()
{
	if (stdStream)
	{
		int ch = stdStream->get();
		if (stdStream->eof())
		{
			return EoF;
		}
		return ch;
	}

	if (bufPos < bufLen) {
		return buf[bufPos++];
	}
	else if (GetPos() < fileLen) {
		SetPos(GetPos()); // shift buffer start to Pos
		return buf[bufPos++];
	}
	else if (cStream && !CanSeek() && (ReadNextStreamChunk() > 0)) {
		return buf[bufPos++];
	}
	else {
		return EoF;
	}
}


int UTF8Buffer::Read()
{
	int ch;
	do {
		ch = Buffer::Read();
		// until we find a utf8 start (0xxxxxxx or 11xxxxxx)
	} while (ch != EoF && ch >= 128 && ((ch & 0xC0) != 0xC0));
	if (ch < 128 || ch == EoF) {
		// nothing to do, first 127 chars are identical in ASCII and UTF8
		// 0xxxxxxx or end of file character
	}
	else if ((ch & 0xF0) == 0xF0) {
		// 0x00010000 - 0x001FFFFF [min. 24bit storage, 4-byte encoding]
		// 11110ccc 10ccbbbb 10bbbbaa 10aaaaaa
		// CAUTION: this should probably be disallowed since it overflows
		// wchar_t on windows and overflows the max (0xFFFF) used here
		int c1 = ch & 0x07; ch = Buffer::Read();
		int c2 = ch & 0x3F; ch = Buffer::Read();
		int c3 = ch & 0x3F; ch = Buffer::Read();
		int c4 = ch & 0x3F;
		ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
	}
	else if ((ch & 0xE0) == 0xE0) {
		// 0x00000800 - 0x0000FFFF [min. 16bit storage, 3-byte encoding]
		// 1110bbbb 10bbbbaa 10aaaaaa
		int c1 = ch & 0x0F; ch = Buffer::Read();
		int c2 = ch & 0x3F; ch = Buffer::Read();
		int c3 = ch & 0x3F;
		ch = (((c1 << 6) | c2) << 6) | c3;
	}
	else if ((ch & 0xC0) == 0xC0) {
		// 0x00000080 - 0x000007FF [min. 16bit storage, 2-byte encoding]
		// 110bbbaa 10aaaaaa
		int c1 = ch & 0x1F; ch = Buffer::Read();
		int c2 = ch & 0x3F;
		ch = (c1 << 6) | c2;
	}
	return ch;
}


bool Buffer::isUTF8() const
{
	return false;
}


bool UTF8Buffer::isUTF8() const
{
	return true;
}


int Buffer::Peek()
{
	int curPos = GetPos();
	int ch = Read();
	SetPos(curPos);
	return ch;
}


int Buffer::GetPos() const
{
	if (stdStream)
	{
		return stdStream->tellg();
	}

	return bufPos + bufStart;
}


void Buffer::SetPos(int value)
{
	if (stdStream)
	{
		stdStream->seekg(value, std::ios::beg);
		return;
	}

	if ((value >= fileLen) && cStream && !CanSeek())
	{
		// Wanted position is after buffer and the stream
		// is not seek-able e.g. network or console,
		// thus we have to read the stream manually till
		// the wanted position is in sight.
		while ((value >= fileLen) && (ReadNextStreamChunk() > 0))
		{}
	}

	if ((value < 0) || (value > fileLen))
	{
		wprintf(L"--- buffer out of bounds access, position: %d\n", value);
		::exit(1);
	}

	if ((value >= bufStart) && (value < (bufStart + bufLen))) // already in buffer
	{
		bufPos = value - bufStart;
	}
	else if (cStream) // must be swapped in
	{
		fseek(cStream, value, SEEK_SET);
		bufLen = fread(buf, sizeof(char), bufCapacity, cStream);
		bufStart = value; bufPos = 0;
	}
	else
	{
		bufPos = fileLen - bufStart; // make Pos return fileLen
	}
}


// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk()
{
	int freeLen = bufCapacity - bufLen;
	if (freeLen == 0)
	{
		// in the case of a growing input stream
		// we can neither seek in the stream, nor can we
		// foresee the maximum length, thus we must adapt
		// the buffer size on demand.
		bufCapacity = bufLen * 2;
		unsigned char *newBuf = new unsigned char[bufCapacity];
		memcpy(newBuf, buf, bufLen*sizeof(char));
		delete[] buf;
		buf = newBuf;
		freeLen = bufLen;
	}
	int read = fread(buf + bufLen, sizeof(char), freeLen, cStream);
	if (read > 0)
	{
		fileLen = bufLen = (bufLen + read);
		return read;
	}
	// end of stream reached
	return 0;
}


bool Buffer::CanSeek() const
{
	return cStream && (ftell(cStream) != -1);
}


// ----------------------------------------------------------------------------
// Scanner Implementation
// ----------------------------------------------------------------------------

Scanner::Scanner(FILE* istr)
:
	buffer(new Buffer(istr, true))
{
	Init();
}


Scanner::Scanner(std::istream& istr)
:
	buffer(new Buffer(&istr, true))
{
	Init();
}


Scanner::Scanner(const std::string& fileName)
{
	FILE* istr;
	if ((istr = fopen(fileName.c_str(), "rb")) == NULL)
	{
		wprintf(L"--- Cannot open file %s\n", fileName.c_str());
		::exit(1);
	}
	buffer = new Buffer(istr, false);
	Init();
}

#ifdef _WIN32
Scanner::Scanner(const std::wstring& fileName)
{
	FILE* istr;

	if ((istr = _wfopen(fileName.c_str(), L"rb")) == NULL)
	{
		wprintf(L"--- Cannot open file %ls\n", fileName.c_str());
		::exit(1);
	}
	buffer = new Buffer(istr, false);
	Init();
}
#endif


Scanner::Scanner(const unsigned char* buf, int len)
:
	buffer(new Buffer(buf, len))
{
	Init();
}


Scanner::Scanner(const char* buf, int len)
:
	buffer(new Buffer(buf, len))
{
	Init();
}


Scanner::~Scanner()
{
	char* cur = reinterpret_cast<char*>(firstHeap);

	while (cur)
	{
		cur = *(reinterpret_cast<char**>(cur + HEAP_BLOCK_SIZE));
		free(firstHeap);
		firstHeap = cur;
	}
	delete[] tval;
	delete buffer;
}


void Scanner::Init()
{
-->declarations    // <-- define start sets and literals

	tvalLength = 128;
	tval = new wchar_t[tvalLength]; // text of current token
	tlen = 0;
	tval[tlen] = 0;

	// HEAP_BLOCK_SIZE byte heap + pointer to next heap block
	heap = malloc(HEAP_BLOCK_SIZE + sizeof(void*));
	firstHeap = heap;
	heapEnd =
		reinterpret_cast<void**>
		(reinterpret_cast<char*>(heap) + HEAP_BLOCK_SIZE);
	*heapEnd = 0;
	heapTop = heap;
	if (sizeof(Token) > HEAP_BLOCK_SIZE)
	{
		wprintf(L"--- Too small HEAP_BLOCK_SIZE\n");
		::exit(1);
	}

	pos = -1; line = 1; col = 0;
	oldEols = 0;
	NextCh();
	if (ch == 0xEF)   // check optional byte order mark for UTF-8
	{                 // Windows-specific magic
		NextCh(); int ch1 = ch;
		NextCh(); int ch2 = ch;
		if (ch1 != 0xBB || ch2 != 0xBF)
		{
			wprintf(L"Illegal byte order mark at start of file");
			::exit(1);
		}
		Buffer *oldBuf = buffer;
		buffer = new UTF8Buffer(oldBuf); col = 0;
		delete oldBuf; oldBuf = NULL;
		NextCh();
	}
	// likely need this chunk of code for non-windows systems, they don't
	// rely on a byte order mark. Should make it selectable via a directive
	// or command-line option etc.
// #ifndef _WIN32
// 	else
// 	{
// 		Buffer *oldBuf = buffer;
// 		buffer = new UTF8Buffer(oldBuf); col = 0;
// 		delete oldBuf; oldBuf = NULL;
// 	}
// #endif

	pt = tokens = CreateToken(); // first token is a dummy
}


void Scanner::NextCh()
{
	if (oldEols > 0)
	{
		ch = EOL;
		oldEols--;
	}
	else
	{
		pos = buffer->GetPos();
		ch = buffer->Read(); col++;
		// replace isolated '\r' by '\n' in order to make
		// eol handling uniform across Windows, Unix and Mac
		if (ch == '\r' && buffer->Peek() != '\n') ch = EOL;
		if (ch == EOL) { line++; col = 0; }
	}
-->casing1    // <-- copy ch to valCh and change to lowercase (as required)
}


void Scanner::AddCh()
{
	if (tlen >= tvalLength)
	{
		tvalLength *= 2;
		wchar_t *newBuf = new wchar_t[tvalLength];
		memcpy(newBuf, tval, tlen*sizeof(wchar_t));
		delete[] tval;
		tval = newBuf;
	}
	if (ch != Buffer::EoF)
	{
-->casing2    // <-- copy ch or valCh to tval
		NextCh();
	}
}


-->comments    // <-- define the comment handlers

void Scanner::CreateHeapBlock()
{
	char* cur = reinterpret_cast<char*>(firstHeap);

	// release unused blocks
	while
	(
	    (reinterpret_cast<char*>(tokens) < cur)
	 || (reinterpret_cast<char*>(tokens) > (cur + HEAP_BLOCK_SIZE))
	)
	{
		cur = *(reinterpret_cast<char**>(cur + HEAP_BLOCK_SIZE));
		free(firstHeap);
		firstHeap = cur;
	}

	// HEAP_BLOCK_SIZE byte heap + pointer to next heap block
	void* newHeap = malloc(HEAP_BLOCK_SIZE + sizeof(void*));
	*heapEnd = newHeap;
	heapEnd =
		reinterpret_cast<void**>
		(reinterpret_cast<char*>(newHeap) + HEAP_BLOCK_SIZE);
	*heapEnd = 0;
	heap = newHeap;
	heapTop = heap;
}


Token* Scanner::CreateToken()
{
	const int reqMem = sizeof(Token);
	if
	(
	    (reinterpret_cast<char*>(heapTop) + reqMem)
	 >= reinterpret_cast<char*>(heapEnd)
	)
	{
		CreateHeapBlock();
	}
	// token 'occupies' heap starting at heapTop
	Token* tok = reinterpret_cast<Token*>(heapTop);
	// increment past this part of the heap, which is now used
	heapTop =
		reinterpret_cast<void*>
		(reinterpret_cast<char*>(heapTop) + reqMem);
	tok->val  = NULL;
	tok->next = NULL;
	return tok;
}


void Scanner::AppendVal(Token* tok)
{
	const int reqMem = (tlen + 1) * sizeof(wchar_t);
	if
	(
	    (reinterpret_cast<char*>(heapTop) + reqMem)
	 >= reinterpret_cast<char*>(heapEnd)
	)
	{
		if (reqMem > HEAP_BLOCK_SIZE)
		{
			wprintf(L"--- Too long token value\n");
			::exit(1);
		}
		CreateHeapBlock();
	}

	// add text value from heap
	tok->val = reinterpret_cast<wchar_t*>(heapTop);

	// increment past this part of the heap, which is now used
	heapTop =
		reinterpret_cast<void*>
		(reinterpret_cast<char*>(heapTop) + reqMem);

	// copy the currently parsed tval into the token
	wcsncpy(tok->val, tval, tlen);
	tok->val[tlen] = '\0';
}


Token* Scanner::NextToken()
{
	while
	(
	    ch == ' '
-->scan1    // <-- add in other IGNORE characters
	) NextCh();
-->scan2    // <-- comment skipping handlers
	t = CreateToken();
	t->pos = pos; t->col = col; t->line = line;
	int state = start.state(ch);
	tlen = 0; AddCh();

	switch (state)
	{
		case -1: { t->kind = eofSym; break; } // NextCh already done
		case 0: { t->kind = noSym; break; }   // NextCh already done
-->scan3    // <-- add in logic
	}
	AppendVal(t);
	return t;
}


// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan()
{
	if (tokens->next == NULL) {
		pt = tokens = NextToken();
	}
	else {
		pt = tokens = tokens->next;
	}
	return tokens;
}


// peek for the next token, ignore pragmas
Token* Scanner::Peek()
{
	do
	{
		if (pt->next == NULL)
		{
			pt->next = NextToken();
		}
		pt = pt->next;
	} while (pt->kind > maxT);   // skip pragmas

	return pt;
}


// make sure that peeking starts at the current scan position
void Scanner::ResetPeek()
{
	pt = tokens;
}


int Scanner::Line() const
{
	return line;
}


void Scanner::Line(int lineNo)
{
	line = lineNo;
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

-->namespace_close    // <-- close the namespace(s)

// ************************************************************************* //
$$$    // <-- end of frame marker
