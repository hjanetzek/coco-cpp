/*---------------------------------------------------------------------------*\
   Coco-cpp.atg -- Attributed Grammar for Coco/R  (-*- C++ -*- version)
   compile with:
       coco-cpp Coco-cpp.atg

   Note that $define=XXX grammar directives can be used to influence
   the output. See the Scanner.frame and Parser.frame for known defines.
\*---------------------------------------------------------------------------*/
[copy]
/*---------------------------------*- C++ -*---------------------------------*\
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    ported to C++ by Csaba Balazs, University of Szeged
    with improvements by Pat Terry, Rhodes University
-------------------------------------------------------------------------------
License
    This file is part of Compiler Generator Coco/R

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
\*---------------------------------------------------------------------------*/
[/copy]

#include "Tab.h"
#include "DFA.h"
#include "ParserGen.h"


COMPILER Coco
$namespace=Coco         // grammar directive

// Parser Data Members and Methods
private:
	static const int isIdent = 0;
	static const int isLiteral = 1;
	static const std::wstring noString;  //!< used in declarations of literal tokens

	bool genScanner;
	std::wstring tokenString;   //!< used in declarations of literal tokens

public:
	Tab *tab;        // other Coco objects referenced in this ATG
	DFA *dfa;        // other Coco objects referenced in this ATG
	ParserGen *pgen; // other Coco objects referenced in this ATG

/*-------------------------------------------------------------------------*/

[initialize]   // Added to Parser constructor
	genScanner = false;
	tab = NULL;
	dfa = NULL;
	pgen = NULL;
[/initialize]

[destroy]      // Added to Parser destructor
	delete tab;   // cleanup sub-elements
	delete pgen;
	delete dfa;
[/destroy]

[code]         // Added to Parser.cpp
const std::wstring Parser::noString(L"-none-");
[/code]

/*-------------------------------------------------------------------------*/

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\u0020' .. '\u007e'.
    alphanum  = digit + letter.
    hex       = digit + "abcdef".

TOKENS
    ident     = letter { alphanum }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { alphanum }.
                        (. Tab::SetDDT(coco_stdString(la->val+1)); .)

    directive = '$' letter { letter } '='
        { alphanum | '-' | '.' | ':' } .
                        (. tab->DispatchDirective(coco_stdString(la->val+1)); .)


COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. Symbol *sym; Graph *g; std::wstring grammarName; CharSet *s; .)
=

  // copyrights, notices, comments, etc. to add to the generated files
  [ "[copy]"                    (. int beg = t->pos + t->length(); int line = t->line; .)
    { ANY }                     (. tab->copyPos = new Position(beg, la->pos, 0, line); .)
    "[/copy]"
  ]

  // this section can be used for #include statements
  [
    ANY                         (. int beg = t->pos; int line = t->line; .)
    { ANY }                     (. pgen->preamblePos = new Position(beg, la->pos, 0, line); .)
  ]

  "COMPILER"                    (. genScanner = true; .)
  ident                         (. grammarName = t->val; .)

  // semantic declarations - ie, class members and methods
  [ ANY                         (. int beg = t->pos; int line = t->line; .)
    { ANY }                     (. pgen->semDeclPos = new Position(beg, la->pos, 0, line); .)
  ]

  // this section can be used to add code to the constructor
  [ "[initialize]"
    [ ANY                       (. int beg = t->pos; int line = t->line; .)
      { ANY }                   (. pgen->initCodePos = new Position(beg, la->pos, 0, line); .)
    ]
    "[/initialize]"
  ]

  // this section can be used to add code to the destructor
  [ "[destroy]"
    [ ANY                       (. int beg = t->pos; int line = t->line; .)
      { ANY }                   (. pgen->deinitCodePos = new Position(beg, la->pos, 0, line); .)
    ]
    "[/destroy]"
  ]

  // this section can be used to add code to the Parser.cpp
  [ "[code]"
    [ ANY                       (. int beg = t->pos; int line = t->line; .)
      { ANY }                   (. pgen->extraCodePos = new Position(beg, la->pos, 0, line); .)
    ]
    "[/code]"
  ]

  [ "IGNORECASE"                (. dfa->ignoreCase = true; .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<Node::t> }]
  [ "PRAGMAS" { TokenDecl<Node::pr> }]
  { "COMMENTS"                  (. Graph *g1, *g2; bool nested = false; .)
    "FROM" TokenExpr<g1>
    "TO" TokenExpr<g2>
    [ "NESTED"                  (. nested = true; .)
    ]                           (. dfa->NewComment(g1->l, g2->l, nested); .)
  }
  { "IGNORE" Set<s>             (. tab->ignored->Or(s); .)
  }

  SYNC
  "PRODUCTIONS"                 (. if (genScanner) dfa->MakeDeterministic();
                                   tab->DeleteNodes();
                                 .)
  { ident                       (. sym = tab->FindSym(t->val);
                                   bool undef = (sym == NULL);
                                   if (undef) sym = tab->NewSym(Node::nt, t->val, t->line);
                                   else {
                                     if (sym->typ == Node::nt) {
                                       if (sym->graph != NULL)
                                         SemErr(L"name declared twice");
                                     } else {
                                         SemErr(L"this symbol kind not allowed on left side of production");
                                     }
                                     sym->line = t->line;
                                   }
                                   bool noAttrs = (sym->attrPos == NULL);
                                   sym->attrPos = NULL;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef && noAttrs != (sym->attrPos == NULL))
                                     SemErr(L"attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<.sym->semPos.> ] WEAK
    '='
    Expression<g>               (. sym->graph = g->l;
                                   tab->Finish(g);
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (grammarName != t->val)
                                     SemErr(L"name does not match grammar name");
                                   tab->gramSy = tab->FindSym(grammarName);
                                   if (tab->gramSy == NULL)
                                     SemErr(L"missing production for grammar name");
                                   else {
                                     sym = tab->gramSy;
                                     if (sym->attrPos != NULL)
                                       SemErr(L"grammar symbol must not have attributes");
                                   }
                                   tab->noSym = tab->NewSym(Node::t, L"???", 0); // noSym gets highest number
                                   tab->SetupAnys();
                                   tab->RenumberPragmas();
                                   if (tab->ddt[2]) tab->PrintNodes();
                                   if (errors->count == 0) {
                                     wprintf(L"checking\n");
                                     tab->CompSymbolSets();
                                     if (tab->ddt[7]) tab->XRef();
                                     if (tab->GrammarOk()) {
                                       wprintf(L"parser");
                                       pgen->WriteParser();
                                       if (genScanner) {
                                         wprintf(L" + scanner");
                                         dfa->WriteScanner();
                                         if (tab->ddt[0]) dfa->PrintStates();
                                       }
                                       wprintf(L" generated\n");
                                       if (tab->ddt[8]) {
                                           tab->PrintStatistics();
                                           pgen->PrintStatistics();
                                           dfa->PrintStatistics();
                                       }
                                     }
                                   }
                                   if (tab->ddt[6]) tab->PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CharSet *s; .)
=
  ident                         (. std::wstring name = t->val;
                                   CharClass *c = tab->FindCharClass(name);
                                   if (c != NULL) {
                                     SemErr(L"name declared twice");
                                   }
                                 .)
  '=' Set<s>                    (. if (s->Elements() == 0) {
                                     SemErr(L"character set must not be empty");
                                   }
                                   tab->NewCharClass(name, s);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<CharSet* &s>                (. CharSet *s2; .)
=
  SimSet<s>
  { '+' SimSet<s2>              (. s->Or(s2); .)
  | '-' SimSet<s2>              (. s->Subtract(s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<CharSet* &s>             (. int n1, n2; s = new CharSet(); .)
=
( ident                         (. CharClass *c = tab->FindCharClass(t->val);
                                   if (c == NULL) SemErr(L"undefined name"); else s->Or(c->set);
                                .)
| string                        (.
                                   std::wstring name = tab->Unescape
                                   (
                                       std::wstring(t->val, 1, t->length()-2)
                                   );
                                   for
                                   (
                                       std::wstring::const_iterator iter = name.begin();
                                       iter != name.end();
                                       ++iter
                                   )
                                   {
                                       wchar_t ch = *iter;
                                       if (dfa->ignoreCase && ch >= 'A' && ch <= 'Z')
                                       {
                                           ch += ('a' - 'A'); // ch.ToLower()
                                       }
                                       s->Set(ch);
                                   }
                                .)
| Char<n1>                      (. s->Set(n1); .)
  [ ".." Char<n2>               (. for (int i = n1; i <= n2; i++) s->Set(i); .)
  ]
| "ANY"                         (. s = new CharSet(); s->Fill(); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<int &n>
=
  char                          (. n = 0;
                                   std::wstring name = tab->Unescape
                                   (
                                       std::wstring(t->val, 1, t->length()-2)
                                   );
                                   // "<= 1" instead of "== 1" to allow the escape sequence '\0' in C++
                                   if (name.size() == 1)
                                   {
                                       n = name[0];
                                   }
                                   else if (!name.empty())
                                   {
                                       SemErr(L"unacceptable character value");
                                   }
                                   // n is int, we can create lowercase directly
                                   if (dfa->ignoreCase && n >= 'A' && n <= 'Z')
                                   {
                                       n += ('a' - 'A');
                                   }
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<Node::nodeType typ>   (. std::wstring name; int kind; Graph *g; .)
=
  Sym<name, kind>               (. Symbol *sym = tab->FindSym(name);
                                   if (sym != NULL) SemErr(L"name declared twice");
                                   else {
                                     sym = tab->NewSym(typ, name, t->line);
                                     sym->tokenKind = Symbol::fixedToken;
                                   }
                                   tokenString.clear();
                                 .)
  SYNC
  ( '=' TokenExpr<g> '.'        (. if (kind == isLiteral) SemErr(L"a literal must not be declared with a structure");
                                   tab->Finish(g);
                                   if (tokenString.empty() || tokenString == noString)
                                     dfa->ConvertToStates(g->l, sym);
                                   else { // TokenExpr is a single string
                                     if (tab->literals[tokenString] != NULL)
                                       SemErr(L"token string declared twice");
                                     tab->literals.Set(tokenString, sym);
                                     dfa->MatchLiteral(tokenString, sym);
                                   }
                                 .)
  |                             (. if (kind == isIdent) genScanner = false;
                                   else dfa->MatchLiteral(sym->name, sym);
                                 .)
  )
  [ SemText<.sym->semPos.>      (. if (typ != Node::pr) SemErr(L"semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol *sym>
=
  '<'                           (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  '>'                           (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos, col, line); .)
| "<."                          (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  ".>"                          (. if (t->pos > beg)
                                     sym->attrPos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Expression<Graph* &g>           (. Graph *g2; .)
=
  Term<g>                       (. bool first = true; .)
  {                         WEAK
    '|'
    Term<g2>                    (. if (first) { tab->MakeFirstAlt(g); first = false; }
                                   tab->MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<Graph* &g>                 (. Graph *g2; Node *rslv = NULL; g = NULL; .)
=
( [                             (. rslv = tab->NewNode(Node::rslv, NULL, la->line); .)
    Resolver<.rslv->pos.>       (. g = new Graph(rslv); .)
  ]
  Factor<g2>                    (. if (rslv != NULL) tab->MakeSequence(g, g2);
                                   else g = g2; .)
  { Factor<g2>                  (. tab->MakeSequence(g, g2); .)
  }
|                               (. g = new Graph(tab->NewNode(Node::eps)); .)
)                               (. if (g == NULL) // invalid start of Term
                                     g = new Graph(tab->NewNode(Node::eps)); .)
.

/*------------------------------------------------------------------------------------*/

Factor<Graph* &g>               (. std::wstring name; int kind; Position *pos; bool weak = false;
                                   g = NULL;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<name, kind>               (. Symbol *sym = tab->FindSym(name);
                                   if (sym == NULL && kind == isLiteral)
                                     sym = tab->literals[name];
                                   bool undef = (sym == NULL);
                                   if (undef) {
                                     if (kind == isIdent)
                                       sym = tab->NewSym(Node::nt, name, 0);  // forward nt
                                     else if (genScanner) {
                                       sym = tab->NewSym(Node::t, name, t->line);
                                       dfa->MatchLiteral(sym->name, sym);
                                     } else {  // undefined string in production
                                       SemErr(L"undefined string in production");
                                       sym = tab->eofSy;  // dummy
                                     }
                                   }
                                   Node::nodeType typ = sym->typ;
                                   if (typ != Node::t && typ != Node::nt)
                                     SemErr(L"this symbol kind is not allowed in a production");
                                   if (weak) {
                                     if (typ == Node::t) typ = Node::wt;
                                     else SemErr(L"only terminals may be weak");
                                   }
                                   Node *p = tab->NewNode(typ, sym, t->line);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (kind == isLiteral) SemErr(L"a literal must not have attributes"); .)
  ]                             (. if (undef)
                                     sym->attrPos = p->pos;  // dummy
                                   else if ((p->pos == NULL) != (sym->attrPos == NULL))
                                     SemErr(L"attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<g> ')'
| '[' Expression<g> ']'         (. tab->MakeOption(g); .)
| '{' Expression<g> '}'         (. tab->MakeIteration(g); .)
| SemText<pos>                  (. Node *p = tab->NewNode(Node::sem);
                                   p->pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. Node *p = tab->NewNode(Node::any);  // p.set is set in tab->SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. Node *p = tab->NewNode(Node::sync);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == NULL) // invalid start of Factor
                                     g = new Graph(tab->NewNode(Node::eps));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<Position* &pos>
=
  "IF" "("                      (. int beg = la->pos; int col = la->col; int line = la->line; .)
  Condition                     (. pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<Graph* &g>            (. Graph *g2; .)
=
  TokenTerm<g>                  (. bool first = true; .)
  {                         WEAK
    '|'
    TokenTerm<g2>               (. if (first) { tab->MakeFirstAlt(g); first = false; }
                                   tab->MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<Graph* &g>            (. Graph *g2; .)
=
  TokenFactor<g>
  { TokenFactor<g2>             (. tab->MakeSequence(g, g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<g2>           (. tab->SetContextTrans(g2->l);
                                   dfa->hasCtxMoves = true;
                                   tab->MakeSequence(g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<Graph* &g>          (. std::wstring name; int kind; g = NULL; .)
=
( Sym<name, kind>               (. if (kind == isIdent) {
                                     CharClass *c = tab->FindCharClass(name);
                                     if (c == NULL) {
                                       SemErr(L"undefined name");
                                       c = tab->NewCharClass(name, new CharSet());
                                     }
                                     Node *p = tab->NewNode(Node::clas); p->val = c->n;
                                     g = new Graph(p);
                                     tokenString = noString;
                                   } else { // str
                                     g = tab->StrToGraph(name);
                                     if (tokenString.empty()) tokenString = name;
                                     else tokenString = noString;
                                   }
                                .)
| '(' TokenExpr<g> ')'
| '[' TokenExpr<g> ']'          (. tab->MakeOption(g); .)
| '{' TokenExpr<g> '}'          (. tab->MakeIteration(g); .)
)                               (. if (g == NULL) // invalid start of TokenFactor
                                     g = new Graph(tab->NewNode(Node::eps)); .)
.

/*------------------------------------------------------------------------------------*/

Sym<std::wstring &name, int &kind> (. name = L"???"; kind = isIdent; .)
=
( ident                         (. kind = isIdent; name = t->val; .)
| (string                       (. name = t->val; .)
  | char                        (. name = t->val;
                                   // change surrounding single quotes to double quotes (does not escape '"')
                                   name[0] = name[name.size()-1] = '"';
                                .)
  )                             (. kind = isLiteral;
                                   if (dfa->ignoreCase) {
                                     for
                                     (
                                         std::wstring::iterator iter = name.begin();
                                         iter != name.end();
                                         ++iter
                                     )
                                     {
                                       if (*iter >= 'A' && *iter <= 'Z') {
                                         *iter += ('a' - 'A'); // ToLower()
                                       }
                                     }
                                   }
                                   if (name.find_first_of(L"\t\r\n ") != std::wstring::npos)
                                     SemErr(L"literal tokens must not contain blanks");
                                .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node *p>
=
  '<'                           (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  '>'                           (. if (t->pos > beg) p->pos = new Position(beg, t->pos, col, line); .)
| "<."                          (. int beg = la->pos; int col = la->col; int line = la->line; .)
  { ANY
  | badString                   (. SemErr(L"bad string in attributes"); .)
  }
  ".>"                          (. if (t->pos > beg) p->pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

SemText<Position* &pos>
=
  "(."                          (. int beg = la->pos; int col = la->col; int line = t->line; .)
  { ANY
  | badString                   (. SemErr(L"bad string in semantic action"); .)
  | "(."                        (. SemErr(L"missing end of previous semantic action"); .)
  }
  ".)"                          (. pos = new Position(beg, t->pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

END Coco.
