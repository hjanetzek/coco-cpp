/*---------------------------------*- C++ -*---------------------------------*\
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    ported to C++ by Csaba Balazs, University of Szeged
    with improvements by Pat Terry, Rhodes University
-------------------------------------------------------------------------------
License
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

About this file
    This is a so-called 'frame' file that contains skeleton code for
    generating a final Scanner/Parser code.

    The '-->TAG' text markers are used to delimit code chunks and typically
    correspond to places where additional information is added by the
    DFA or ParserGen code. These tag must be the first token to appear
    on a line. Lines containing this text marker are not output.

    All information prior to the first 'begin' text marker is discarded.
    If the grammar contains a '[copy]' .. '[/copy]' section, its contents
    will added instead.

    Note that the frame file also includes a modest preprocessor capability.
    Preprocessor directives start with '$' and are limited to these values:\n
        - \$ifdef NAME
        - \$ifndef NAME
        - \$else
        - \$endif

    These preprocessor directives can be useful to selective enable/disable
    parts of the frame code by adding corresponding '\$define=NAME'
    and '\$undef=NAME' directives to the ATG grammar.

    Note that since the '-->TAG' text markers are seen before the
    preprocessor directives, the directives have no effect there.

Defines used
    - EXPLICIT_EOF
      grammar must deal with end-of-file expectations explicitly

\*---------------------------------------------------------------------------*/
-->begin    // <-- ignore all preliminary text

#ifndef COCO_$PREFIX$PARSER_H__
#define COCO_$PREFIX$PARSER_H__

-->headerdef    // <-- add in preamble (eg, includes)

#include "$PREFIX$Scanner.h"

-->namespace_open    // <-- open the namespace(s)


/*---------------------------------------------------------------------------*\
                           Class Errors Declaration
\*---------------------------------------------------------------------------*/
//! Parser error handing
class Errors
{
public:
	int count;      //!< The number of errors detected

	//! Return a string describing the given error code.
	static std::wstring strerror(int n);

	Errors();               //!< Construct null - start with no errors
	virtual ~Errors();      //!< Destructor
	virtual void clear();   //!< Clear the error count

	//! Handle a general warning 'msg'
	virtual void Warning(const std::wstring& msg);
	//! Handle a general warning 'msg'
	virtual void Warning(int line, int col, const std::wstring& msg);
	//! Handle general error 'msg' (eg, a semantic error)
	virtual void Error(int line, int col, const std::wstring& msg);
	//! Handle syntax error 'n', uses strerror for the message, calls Error()
	virtual void SynErr(int line, int col, int n);
	//! Handle a general exception 'msg'
	virtual void Exception(const std::wstring& msg);

}; // Errors



/*---------------------------------------------------------------------------*\
                           Class Parser Declaration
\*---------------------------------------------------------------------------*/
//! A Coco/R Parser
class Parser
{
-->constantsheader    // <-- add enum with the token kinds and maxT
	static const int minErrDist = 2; //!< min. distance before reporting errors

	Token *dummyToken;
	bool deleteErrorsDestruct_; //!< delete the 'errors' member in destructor
	int  errDist;

	void SynErr(int n);         //!< Handle syntax error 'n'
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;                   //!< last recognized token
	Token *la;                  //!< lookahead token

-->declarations    // <-- add user-defined date and method declarations

	//! Construct for the specified scanner
	/*!
	 * Use the default error handling, or optionally provide an error
	 * handler, which will not be deleted upon destruction.
	 */
	Parser(Scanner* scan, Errors* err = 0);
	~Parser();
	void Parse();                          //!< Execute the parse operation
	void SemErr(const std::wstring& msg);  //!< Handle semantic error
	bool isUTF8() const;   //!< Return true if scanner buffer is UTF8

-->productionsheader   // <-- productions headers

}; // end Parser

-->namespace_close    // <-- close the namespace(s)

#endif // COCO_$PREFIX$PARSER_H__

// ************************************************************************* //
-->implementation    // <-- start the implementation itself

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cwchar>
#include <sstream>

#include "$PREFIX$Parser.h"

-->namespace_open    // <-- open the namespace(s)


//! @cond fileScope
//

//
//  Create by copying str - only used locally
inline static wchar_t* coco_string_create(const wchar_t* str)
{
	const int len = wcslen(str);
	wchar_t* dest = new wchar_t[len + 1];
	wcsncpy(dest, str, len);
	dest[len] = 0;
	return dest;
}


// Free storage and nullify the argument
inline static void coco_string_delete(wchar_t* &str)
{
	delete[] str;
	str = NULL;
}
//
//! @endcond fileScope


// ----------------------------------------------------------------------------
// Parser Implementation
// ----------------------------------------------------------------------------

void Parser::SynErr(int n)
{
	if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
	errDist = 0;
}


void Parser::SemErr(const std::wstring& msg)
{
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}


bool Parser::isUTF8() const
{
	return scanner && scanner->buffer && scanner->buffer->isUTF8();
}


void Parser::Get()
{
	for (;;)
	{
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT)
		{
			++errDist;
			break;
		}
-->pragmas    // <-- add in pragma handlers
		if (dummyToken != t)
		{
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}


void Parser::Expect(int n)
{
	if (la->kind == n)
	{
		Get();
	}
	else
	{
		SynErr(n);
	}
}


void Parser::ExpectWeak(int n, int follow)
{
	if (la->kind == n)
	{
		Get();
	}
	else
	{
		SynErr(n);
		while (!StartOf(follow))
		{
			Get();
		}
	}
}


bool Parser::WeakSeparator(int n, int syFol, int repFol)
{
	if (la->kind == n)
	{
		Get();
		return true;
	}
	else if (StartOf(repFol))
	{
		return false;
	}
	else
	{
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0)))
		{
			Get();
		}
		return StartOf(syFol);
	}
}


-->productions    // <-- implementation for productions

void Parser::Parse()
{
	t = NULL;
	// might call Parse() twice
	if (dummyToken) {
		coco_string_delete(dummyToken->val);
		delete dummyToken;
	}
	dummyToken = new Token(coco_string_create(L"Dummy Token"));
	la = dummyToken;
	Get();
-->parseRoot    // <-- call main production
$ifdef EXPLICIT_EOF
	// grammar must deal with end-of-file expectations explicitly
$else
	Expect(0);  // expect end-of-file automatically added
$endif
}


Parser::Parser(Scanner* scan, Errors* err)
:
	dummyToken(NULL),
	deleteErrorsDestruct_(!err),
	errDist(minErrDist),
	scanner(scan),
	errors(err),
	t(NULL),
	la(NULL)
{
	if (!errors)    // add in default error handling
	{
		errors = new Errors();
	}
	// user-defined initializations:
-->constructor    // <-- user-defined initializations
}


bool Parser::StartOf(int s)
{
	const bool T = true;
	const bool x = false;

-->initialization    // <-- define start-of set
	return set[s][la->kind];
}


Parser::~Parser()
{
	if (deleteErrorsDestruct_) { delete errors; } // delete default error handling
	if (dummyToken) {
		coco_string_delete(dummyToken->val);
		delete dummyToken;
	}
	// user-defined destruction:
-->destructor    // <-- user-defined destruction
}


// ----------------------------------------------------------------------------
// Errors Implementation
// ----------------------------------------------------------------------------

Errors::Errors()
:
	count(0)
{}


Errors::~Errors()
{}


void Errors::clear()
{
	count = 0;
}


std::wstring Errors::strerror(int n)
{
	switch (n) {
-->errors    // <-- return strings corresponding to error numbers
		default:
		{
			// std::wostringstream buf;  (this typedef might be missing)
			std::basic_ostringstream<wchar_t> buf;
			buf << "error " << n;
			return buf.str();
		}
		break;
	}
}


void Errors::Warning(const std::wstring& msg)
{
	wprintf(L"%ls\n", msg.c_str());
}


void Errors::Warning(int line, int col, const std::wstring& msg)
{
	wprintf(L"-- line %d col %d: %ls\n", line, col, msg.c_str());
}


void Errors::Error(int line, int col, const std::wstring& msg)
{
	wprintf(L"-- line %d col %d: %ls\n", line, col, msg.c_str());
	count++;
}


void Errors::SynErr(int line, int col, int n)
{
	this->Error(line, col, this->strerror(n));
}


void Errors::Exception(const std::wstring& msg)
{
	wprintf(L"%ls", msg.c_str());
	::exit(1);
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

-->namespace_close    // <-- close the namespace(s)

// ************************************************************************* //
$$$    // <-- end of frame marker
