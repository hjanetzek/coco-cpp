/*-------------------------------------------------------------------------
Tab -- Symbol Table Management
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

#include "Tab.h"
#include "Parser.h"
#include "BitArray.h"
#include "Utils.h"
#include "SortedList.h"

namespace Coco
{

// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

const char* Tab::nTyp[] =
{
	"    ", "t   ", "pr  ", "nt  ",
	"clas", "chr ", "wt  ", "any ",
	"eps ", "sync", "sem ", "alt ",
	"iter", "opt ", "rslv"
};

const char* Tab::tKind[] =
{
	"fixedToken", "classToken", "litToken", "classLitToken"
};

const wchar_t* Tab::prefixMacro = L"$PREFIX$";


bool Tab::emitLines = false;
bool Tab::singleOutput = false;
bool Tab::makeBackup = false;
bool Tab::explicitEOF = false;
bool Tab::ddt[10] =
{
	false, false, false, false, false,
	false, false, false, false, false
};


#ifdef _WIN32
std::wstring Tab::srcDir;
std::wstring Tab::frameDir;
std::wstring Tab::outDir;
#else
std::string Tab::srcDir;
std::string Tab::frameDir;
std::string Tab::outDir;
#endif

std::string Tab::nsName;
std::string Tab::prefixName;

FILE* Tab::trace = stderr;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Tab::Tab(Parser *theParser)
:
	copyPos(NULL),
	ignored(new CharSet),
	gramSy(NULL),
	eofSy(NULL),
	noSym(NULL),
	allSyncSets(NULL),
	visited(NULL),
	curSy(NULL),
	parser(theParser),
	errors(parser->errors),
	buffer(parser->scanner->buffer),
	dummyNode(NULL),
	dummyName('A')
{
	eofSy = NewSym(Node::t, L"EOF", 0);
	dummyNode = NewNode(Node::eps);
}


Tab::~Tab()
{
	if (copyPos) { delete copyPos; }
	if (ignored) { delete ignored; }
	if (allSyncSets) { delete allSyncSets; }
	if (visited) { delete visited; }

	terminals.Delete();
	pragmas.Delete();
	nonterminals.Delete();
	nodes.Delete();
	classes.Delete();
}


Symbol* Tab::NewSym(Node::nodeType typ, const wchar_t* name, int line)
{
	if (coco_string_length(name) == 2 && name[0] == '"')
	{
		parser->SemErr(L"empty token not allowed");
		name = coco_string_create(L"???");
	}
	Symbol *sym = new Symbol(typ, name, line);

	if (typ == Node::t)
	{
		sym->n = terminals.Count; terminals.Add(sym);
	}
	else if (typ == Node::pr)
	{
		pragmas.Add(sym);
	}
	else if (typ == Node::nt)
	{
		sym->n = nonterminals.Count; nonterminals.Add(sym);
	}

	return sym;
}


Symbol* Tab::FindSym(const wchar_t* name)
{
	for (int i=0; i < terminals.Count; i++)
	{
		Symbol *sym = terminals[i];
		if (coco_string_equal(sym->name, name)) return sym;
	}
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		if (coco_string_equal(sym->name, name)) return sym;
	}
	return NULL;
}


int Tab::Num(Node *p)
{
	return (p ? p->n : 0);
}


void Tab::PrintSym(Symbol *sym) const
{
	fwprintf(trace, L"%3d %-14ls %s", sym->n, sym->name, nTyp[sym->typ]);

	if (sym->attrPos) fwprintf(trace, L" true  "); else fwprintf(trace, L" false ");
	if (sym->typ == Node::nt)
	{
		fwprintf(trace, L"%5d", Num(sym->graph));
		if (sym->deletable) fwprintf(trace, L" true  "); else fwprintf(trace, L" false ");
	} else
		fwprintf(trace, L"            ");

	fwprintf(trace, L"%5d %s\n", sym->line, tKind[sym->tokenKind]);
}


void Tab::PrintSymbolTable()
{
	fwprintf(trace, L"Symbol Table:\n");
	fwprintf(trace, L"------------\n\n");
	fwprintf(trace, L" nr name           typ  hasAt graph delete line tokenKind\n");

	for (int i=0; i < terminals.Count; i++)
	{
		PrintSym(terminals[i]);
	}
	for (int i=0; i < pragmas.Count; i++)
	{
		PrintSym(pragmas[i]);
	}
	for (int i=0; i < nonterminals.Count; i++)
	{
		PrintSym(nonterminals[i]);
	}


	fwprintf(trace, L"\nLiteral Tokens:\n");
	fwprintf(trace, L"--------------\n");

	HashTable<Symbol>::Iterator iter = literals.GetIterator();
	while (iter.HasNext())
	{
		HashTable<Symbol>::Entry *e = iter.Next();
		fwprintf(trace, L"_%ls =  %ls.\n", e->val->name, e->key);
	}
	fwprintf(trace, L"\n");
}


void Tab::PrintSet(BitArray *s, int indent)
{
	int col = indent;
	for (int i=0; i < terminals.Count; i++)
	{
		Symbol *sym = terminals[i];
		if ((*s)[sym->n])
		{
			const int len = coco_string_length(sym->name);
			if (col + len >= 80)
			{
				fwprintf(trace, L"\n");
				for (col = 1; col < indent; col++) fwprintf(trace, L" ");
			}
			fwprintf(trace, L" %ls", sym->name);
			col += len + 1;
		}
	}
	if (col == indent) fwprintf(trace, L"-- empty set --");
	fwprintf(trace, L"\n");
}


void Tab::PrintStatistics() const
{
	fwprintf(trace, L"Statistics:\n");
	fwprintf(trace, L"----------\n");
	fwprintf(trace, L"%d terminals\n", terminals.Count);
	fwprintf(trace, L"%d symbols\n", terminals.Count + pragmas.Count + nonterminals.Count);
	fwprintf(trace, L"%d nodes\n", nodes.Count);
}


//---------------------------------------------------------------------
//  Syntax graph management
//---------------------------------------------------------------------

Node* Tab::NewNode(Node::nodeType typ, Symbol *sym, int line)
{
	Node* node = new Node(typ, sym, line);
	node->n = nodes.Count;
	nodes.Add(node);
	return node;
}


Node* Tab::NewNode(Node::nodeType typ)
{
	return NewNode(typ, reinterpret_cast<Symbol*>(0), 0);
}


Node* Tab::NewNode(Node::nodeType typ, Node* sub)
{
	Node* node = NewNode(typ);
	node->sub = sub;
	return node;
}


Node* Tab::NewNode(Node::nodeType typ, int val)
{
	Node* node = NewNode(typ);
	node->val = val;
	return node;
}


void Tab::MakeFirstAlt(Graph *g)
{
	g->l = NewNode(Node::alt, g->l); g->l->line = g->l->sub->line;
	g->r->up = true;
	g->l->next = g->r;
	g->r = g->l;
}


// The result will be in g1
void Tab::MakeAlternative(Graph *g1, Graph *g2)
{
	g2->l = NewNode(Node::alt, g2->l); g2->l->line = g2->l->sub->line;
	g2->l->up = true;
	g2->r->up = true;
	Node *p = g1->l; while (p->down != NULL) p = p->down;
	p->down = g2->l;
	p = g1->r; while (p->next != NULL) p = p->next;
	// append alternative to g1 end list
	p->next = g2->l;
	// append g2 end list to g1 end list
	g2->l->next = g2->r;
}


// The result will be in g1
void Tab::MakeSequence(Graph *g1, Graph *g2)
{
	Node *p = g1->r->next; g1->r->next = g2->l; // link head node
	while (p != NULL)   // link substructure
	{
		Node *q = p->next; p->next = g2->l;
		p = q;
	}
	g1->r = g2->r;
}


void Tab::MakeIteration(Graph *g)
{
	g->l = NewNode(Node::iter, g->l);
	g->r->up = true;
	Node *p = g->r;
	g->r = g->l;
	while (p != NULL)
	{
		Node *q = p->next; p->next = g->l;
		p = q;
	}
}


void Tab::MakeOption(Graph *g)
{
	g->l = NewNode(Node::opt, g->l);
	g->r->up = true;
	g->l->next = g->r;
	g->r = g->l;
}


void Tab::Finish(Graph *g)
{
	Node *p = g->r;
	while (p != NULL)
	{
		Node *q = p->next; p->next = NULL;
		p = q;
	}
}


void Tab::DeleteNodes()
{
	nodes.Delete();
	dummyNode = NewNode(Node::eps);
}


Graph* Tab::StrToGraph(const wchar_t* str)
{
	wchar_t *subStr = coco_string_create(str, 1, coco_string_length(str)-2);
	wchar_t *s = Unescape(subStr);
	coco_string_delete(subStr);
	if (coco_string_length(s) == 0) parser->SemErr(L"empty token not allowed");
	Graph *g = new Graph();
	g->r = dummyNode;
	for (int i = 0; i < coco_string_length(s); i++)
	{
		Node *p = NewNode(Node::chr, int(s[i]));
		g->r->next = p; g->r = p;
	}
	g->l = dummyNode->next; dummyNode->next = NULL;
	coco_string_delete(s);
	return g;
}


// set transition code in the graph rooted at p
void Tab::SetContextTrans(Node *p)
{
	while (p != NULL)
	{
		if (p->typ == Node::chr || p->typ == Node::clas)
		{
			p->code = Node::contextTrans;
		}
		else if (p->typ == Node::opt || p->typ == Node::iter)
		{
			SetContextTrans(p->sub);
		}
		else if (p->typ == Node::alt)
		{
			SetContextTrans(p->sub); SetContextTrans(p->down);
		}
		if (p->up) break;
		p = p->next;
	}
}


//------------ graph deletability check -----------------

bool Tab::DelGraph(Node* p)
{
	return p == NULL || (DelNode(p) && DelGraph(p->next));
}


bool Tab::DelSubGraph(Node* p)
{
	return p == NULL || (DelNode(p) && (p->up || DelSubGraph(p->next)));
}


bool Tab::DelNode(Node* p)
{
	if (p->typ == Node::nt)
	{
		return p->sym->deletable;
	}
	else if (p->typ == Node::alt)
	{
		return DelSubGraph(p->sub) || (p->down != NULL && DelSubGraph(p->down));
	}
	else
	{
		return p->typ == Node::iter
			|| p->typ == Node::opt
			|| p->typ == Node::sem
			|| p->typ == Node::eps
			|| p->typ == Node::rslv
			|| p->typ == Node::sync;
	}
}

//----------------- graph printing ----------------------

int Tab::Ptr(Node *p, bool up)
{
	if (p == NULL) return 0;
	else if (up) return -(p->n);
	else return p->n;
}


std::wstring Tab::Pos(Position *pos)
{
	wchar_t format[10];
	if (pos == NULL) {
		coco_swprintf(format, 10, L"     ");
	} else {
		coco_swprintf(format, 10, L"%5d", pos->beg);
	}
	return format;
}


void Tab::PrintNodes()
{
	fwprintf(trace, L"Graph nodes:\n");
	fwprintf(trace, L"------------------------------------------------------\n");
	fwprintf(trace, L"   n type name            next  down   sub   pos  line\n");
	fwprintf(trace, L"                                 val  code\n");
	fwprintf(trace, L"------------------------------------------------------\n");

	for (int i=0; i < nodes.Count; i++)
	{
		Node *p = nodes[i];
		fwprintf(trace, L"%4d %s ", p->n, nTyp[p->typ]);
		if (p->sym != NULL)
		{
			fwprintf(trace, L"%-14ls ", p->sym->name);
		}
		else if (p->typ == Node::clas)
		{
			fwprintf(trace, L"%-14ls ", classes[p->val]->name);
		}
		else
		{
			fwprintf(trace, L"               ");
		}

		fwprintf(trace, L"%5d ", Ptr(p->next, p->up));

		if (p->typ == Node::t || p->typ == Node::nt || p->typ == Node::wt)
		{
			fwprintf(trace, L"             %5s", Pos(p->pos).c_str());
		}
		if (p->typ == Node::chr)
		{
			fwprintf(trace, L"%5d %5d       ", p->val, p->code);
		}
		if (p->typ == Node::clas)
		{
			fwprintf(trace, L"      %5d       ", p->code);
		}
		if (p->typ == Node::alt || p->typ == Node::iter || p->typ == Node::opt)
		{
			fwprintf(trace, L"%5d %5d       ", Ptr(p->down, false), Ptr(p->sub, false));
		}
		if (p->typ == Node::sem)
		{
			fwprintf(trace, L"             %5s", Pos(p->pos).c_str());
		}
		if (p->typ == Node::eps || p->typ == Node::any || p->typ == Node::sync)
		{
			fwprintf(trace, L"                  ");
		}
		fwprintf(trace, L"%5d\n", p->line);
	}
	fwprintf(trace, L"\n");
}


//---------------------------------------------------------------------
//  Character class management
//---------------------------------------------------------------------


CharClass* Tab::NewCharClass(const wchar_t* name, CharSet *s)
{
	CharClass *c;
	if (coco_string_equal(name, L"#"))
	{
		wchar_t autoName[3] = { '#', wchar_t(dummyName++), '\0' };
		c = new CharClass(autoName, s);
	}
	else
	{
		c = new CharClass(name, s);
	}
	c->n = classes.Count;
	classes.Add(c);
	return c;
}


CharClass* Tab::FindCharClass(const wchar_t* name)
{
	for (int i=0; i < classes.Count; i++)
	{
		CharClass *c = classes[i];
		if (coco_string_equal(c->name, name)) return c;
	}
	return NULL;
}


CharClass* Tab::FindCharClass(CharSet *s)
{
	for (int i=0; i < classes.Count; i++)
	{
		CharClass *c = classes[i];
		if (s->Equals(c->set)) return c;
	}
	return NULL;
}


CharSet* Tab::CharClassSet(int i)
{
	return classes[i]->set;
}


//----------- character class printing

std::wstring Tab::Ch(const wchar_t ch)
{
	wchar_t format[10];
	if (ch < 32 || ch >= 0x7F || ch == '\'' || ch == '\\') {
		coco_swprintf(format, 10, L"%d", int(ch));
	} else {
		coco_swprintf(format, 10, L"'%c'", int(ch));
	}
	return format;
}


void Tab::WriteCharSet(CharSet *s)
{
	for (CharSet::Range *r = s->head; r != NULL; r = r->next)
	{
		fwprintf(trace, L" %ls", Ch(r->from).c_str());
		if (r->from < r->to)
		{
			fwprintf(trace, L" .. %ls", Ch(r->to).c_str());
		}
	}
}


void Tab::WriteCharClasses()
{
	for (int i=0; i < classes.Count; i++)
	{
		CharClass *c = classes[i];

		fwprintf(trace, L"%-12ls :", c->name);
		WriteCharSet(c->set);
		fwprintf(trace, L"\n");
	}
	fwprintf(trace, L"\n");
}

//---------------------------------------------------------------------
//  Symbol set computations
//---------------------------------------------------------------------

/* Computes the first set for the given Node. */
BitArray* Tab::First0(Node *p, BitArray *mark)
{
	BitArray *fs = new BitArray(terminals.Count);
	while (p != NULL && !((*mark)[p->n]))
	{
		mark->Set(p->n, true);
		if (p->typ == Node::nt)
		{
			if (p->sym->firstReady)
			{
				fs->Or(p->sym->first);
			}
			else
			{
				BitArray *fs0 = First0(p->sym->graph, mark);
				fs->Or(fs0);
				delete fs0;
			}
		}
		else if (p->typ == Node::t || p->typ == Node::wt)
		{
			fs->Set(p->sym->n, true);
		}
		else if (p->typ == Node::any)
		{
			fs->Or(p->set);
		}
		else if (p->typ == Node::alt)
		{
			BitArray *fs0 = First0(p->sub, mark);
			fs->Or(fs0);
			delete fs0;
			fs0 = First0(p->down, mark);
			fs->Or(fs0);
			delete fs0;
		}
		else if (p->typ == Node::iter || p->typ == Node::opt)
		{
			BitArray *fs0 = First0(p->sub, mark);
			fs->Or(fs0);
			delete fs0;
		}

		if (!DelNode(p)) break;
		p = p->next;
	}
	return fs;
}


BitArray* Tab::First(Node *p)
{
	BitArray *mark = new BitArray(nodes.Count);
	BitArray *fs = First0(p, mark);
	delete mark;
	if (ddt[3])
	{
		fwprintf(trace, L"\n");
		if (p != NULL)
			fwprintf(trace, L"First: node = %d\n", p->n);
		else
			fwprintf(trace, L"First: node = null\n");
		PrintSet(fs, 0);
	}
	return fs;
}


void Tab::CompFirstSets()
{
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		sym->first = new BitArray(terminals.Count);
		sym->firstReady = false;
	}
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		sym->first = First(sym->graph);
		sym->firstReady = true;
	}
}

void Tab::CompFollow(Node *p)
{
	while (p != NULL && !((*visited)[p->n]))
	{
		visited->Set(p->n, true);
		if (p->typ == Node::nt)
		{
			BitArray *s = First(p->next);
			p->sym->follow->Or(s);
			if (DelGraph(p->next))
				p->sym->nts->Set(curSy->n, true);
		}
		else if (p->typ == Node::opt || p->typ == Node::iter)
		{
			CompFollow(p->sub);
		}
		else if (p->typ == Node::alt)
		{
			CompFollow(p->sub); CompFollow(p->down);
		}
		p = p->next;
	}
}


void Tab::Complete(Symbol *sym)
{
	if (!((*visited)[sym->n]))
	{
		visited->Set(sym->n, true);
		for (int i=0; i < nonterminals.Count; i++)
		{
			Symbol *s = nonterminals[i];
			if ((*(sym->nts))[s->n])
			{
				Complete(s);
				sym->follow->Or(s->follow);
				if (sym == curSy) sym->nts->Set(s->n, false);
			}
		}
	}
}


void Tab::CompFollowSets()
{
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		sym->follow = new BitArray(terminals.Count);
		sym->nts = new BitArray(nonterminals.Count);
	}
	gramSy->follow->Set(eofSy->n, true);
	visited = new BitArray(nodes.Count);
	for (int i=0; i < nonterminals.Count; i++)   // get direct successors of nonterminals
	{
		Symbol *sym = nonterminals[i];
		curSy = sym;
		CompFollow(sym->graph);
	}

	for (int i=0; i < nonterminals.Count; i++)  // add indirect successors to followers
	{
		Symbol *sym = nonterminals[i];
		visited = new BitArray(nonterminals.Count);
		curSy = sym;
		Complete(sym);
	}
}


Node* Tab::LeadingAny(Node *p)
{
	if (p == NULL) return NULL;
	Node *a = NULL;
	if (p->typ == Node::any)
	{
		a = p;
	}
	else if (p->typ == Node::alt)
	{
		a = LeadingAny(p->sub);
		if (a == NULL) a = LeadingAny(p->down);
	}
	else if (p->typ == Node::opt || p->typ == Node::iter)
	{
		a = LeadingAny(p->sub);
	}

	if (a == NULL && DelNode(p) && !p->up) a = LeadingAny(p->next);
	return a;
}


void Tab::FindAS(Node *p)  // find ANY sets
{
	Node *a;
	while (p != NULL)
	{
		if (p->typ == Node::opt || p->typ == Node::iter)
		{
			FindAS(p->sub);
			a = LeadingAny(p->sub);
			if (a != NULL) Sets::Subtract(a->set, First(p->next));
		}
		else if (p->typ == Node::alt)
		{
			BitArray *s1 = new BitArray(terminals.Count);
			Node *q = p;
			while (q != NULL)
			{
				FindAS(q->sub);
				a = LeadingAny(q->sub);
				if (a != NULL)
				{
					BitArray *tmp = First(q->down);
					tmp->Or(s1);
					Sets::Subtract(a->set, tmp);
				}
				else
				{
					BitArray *f = First(q->sub);
					s1->Or(f);
					delete f;
				}
				q = q->down;
			}
		}

		// Remove alternative terminals before ANY, in the following
		// examples a and b must be removed from the ANY set:
		// [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
		// A = [a]. A ANY
		if (DelNode(p))
		{
			a = LeadingAny(p->next);
			if (a != NULL)
			{
				Node *q = (p->typ == Node::nt) ? p->sym->graph : p->sub;
				Sets::Subtract(a->set, First(q));
			}
		}

		if (p->up) break;
		p = p->next;
	}
}


void Tab::CompAnySets()
{
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		FindAS(sym->graph);
	}
}


BitArray* Tab::Expected(Node *p, Symbol *curSy)
{
	BitArray *s = First(p);
	if (DelGraph(p))
		s->Or(curSy->follow);
	return s;
}


// does not look behind resolvers; only called during LL(1) test and in CheckRes
BitArray* Tab::Expected0(Node *p, Symbol *curSy)
{
	if (p->typ == Node::rslv)
		return new BitArray(terminals.Count);
	else
		return Expected(p, curSy);
}


void Tab::CompSync(Node *p)
{
	while (p != NULL && !(visited->Get(p->n)))
	{
		visited->Set(p->n, true);

		if (p->typ == Node::sync)
		{
			BitArray *s = Expected(p->next, curSy);
			s->Set(eofSy->n, true);
			allSyncSets->Or(s);
			p->set = s;
		}
		else if (p->typ == Node::alt)
		{
			CompSync(p->sub); CompSync(p->down);
		}
		else if (p->typ == Node::opt || p->typ == Node::iter)
		{
			CompSync(p->sub);
		}

		p = p->next;
	}
}


void Tab::CompSyncSets()
{
	allSyncSets = new BitArray(terminals.Count);
	allSyncSets->Set(eofSy->n, true);
	visited = new BitArray(nodes.Count);

	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		curSy = sym;
		CompSync(curSy->graph);
	}
}


void Tab::SetupAnys()
{
	for (int i=0; i < nodes.Count; i++)
	{
		Node *p = nodes[i];
		if (p->typ == Node::any)
		{
			p->set = new BitArray(terminals.Count, true);
			p->set->Set(eofSy->n, false);
		}
	}
}


void Tab::CompDeletableSymbols()
{
	bool changed;
	do
	{
		changed = false;
		for (int i=0; i < nonterminals.Count; i++)
		{
			Symbol *sym = nonterminals[i];
			if (!sym->deletable && sym->graph != NULL && DelGraph(sym->graph))
			{
				sym->deletable = true;
				changed = true;
			}
		}
	} while (changed);

	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		if (sym->deletable)
			wprintf(L"  %ls deletable\n", sym->name);
	}
}


void Tab::RenumberPragmas()
{
	int n = terminals.Count;
	for (int i=0; i < pragmas.Count; i++)
	{
		Symbol *sym = pragmas[i];
		sym->n = n++;
	}
}


void Tab::CompSymbolSets()
{
	CompDeletableSymbols();
	CompFirstSets();
	CompAnySets();
	CompFollowSets();
	CompSyncSets();
	if (ddt[1])
	{
		fwprintf(trace, L"\n");
		fwprintf(trace, L"First & follow symbols:\n");
		fwprintf(trace, L"----------------------\n");

		for (int i=0; i < nonterminals.Count; i++)
		{
			Symbol *sym = nonterminals[i];
			fwprintf(trace, L"%ls\n", sym->name);
			fwprintf(trace, L" first:  "); PrintSet(sym->first, 10);
			fwprintf(trace, L" follow: "); PrintSet(sym->follow, 10);
			fwprintf(trace, L"\n");
		}
	}
	if (ddt[4])
	{
		fwprintf(trace, L"\n");
		fwprintf(trace, L"ANY and SYNC sets:\n");
		fwprintf(trace, L"-----------------\n");

		for (int i=0; i < nodes.Count; i++)
		{
			Node *p = nodes[i];
			if (p->typ == Node::any || p->typ == Node::sync)
			{
				fwprintf(trace, L"%4d %4s ", p->n, nTyp[p->typ]);
				PrintSet(p->set, 11);
			}
		}
	}
}

//---------------------------------------------------------------------
//  String handling
//---------------------------------------------------------------------

wchar_t Tab::Hex2Char(const wchar_t* s, const int len)
{
	int val = 0;

	for (int i = 0; i < len; i++)
	{
		wchar_t ch = s[i];
		if (ch >= '0' && ch <= '9') val = 16 * val + (ch - '0');
		else if (ch >= 'a' && ch <= 'f') val = 16 * val + (10 + ch - 'a');
		else if (ch >= 'A' && ch <= 'F') val = 16 * val + (10 + ch - 'A');
		else parser->SemErr(L"bad escape sequence in string or character");
	}
	if (val >= COCO_WCHAR_MAX)  /* pdt */
	{
		parser->SemErr(L"bad escape sequence in string or character");
	}
	return val;
}


std::wstring Tab::Char2Hex(const wchar_t ch)
{
	wchar_t format[10];
	coco_swprintf(format, 10, L"\\0x%04x", ch);
	return format;
}


wchar_t* Tab::Unescape(const wchar_t* s)
{
	const int len = coco_string_length(s);
	std::wstring buf;
	buf.reserve(len);

	for (int i = 0; i < len; ++i)
	{
		if (s[i] == '\\')
		{
			++i;            // skip backslash
			switch (s[i])
			{
				case '\\':
				case '\'':
				case '\"':
					buf += s[i];   // escaped char is itself
					break;
				case 'r':  buf += L'\r'; break;
				case 'n':  buf += L'\n'; break;
				case 't':  buf += L'\t'; break;
				case '0':  buf += L'\0'; break;
				case 'a':  buf += L'\a'; break;
				case 'b':  buf += L'\b'; break;
				case 'f':  buf += L'\f'; break;
				case 'v':  buf += L'\v'; break;

				case 'u': case 'x':   // unicode/hex encoding
					if (i + 5 <= len)
					{
						buf += Hex2Char(s+i+1, 4);
						i += 4;
						break;
					}
					else
					{
						parser->SemErr(L"bad escape sequence in string or character");
						i = len;
						break;
					}
				default:
					parser->SemErr(L"bad escape sequence in string or character");
					break;
			}
		}
		else
		{
			buf += s[i];
		}
	}

	return coco_string_create(buf.c_str());
}


std::wstring Tab::Escape(const wchar_t* s)
{
	const int len = coco_string_length(s);

	std::wstring buf;
	buf.reserve(len);

	for (int i=0; i < len; i++)
	{
		wchar_t ch = s[i];
		switch (ch)
		{
			case '\\':  buf += L"\\\\"; break;
			case '\'':  buf += L"\\'";  break;
			case '\"':  buf += L"\\\""; break;
			case '\t':  buf += L"\\t";  break;
			case '\r':  buf += L"\\r";  break;
			case '\n':  buf += L"\\n";  break;
			default:
				if (ch < 32 || ch > 0x7F)
				{
					buf += Char2Hex(ch);
				}
				else
				{
					buf += ch;
				}
				break;
		}
	}

	return buf;
}


//---------------------------------------------------------------------
//  Grammar checks
//---------------------------------------------------------------------

bool Tab::GrammarOk()
{
	bool ok = NtsComplete()
		&& AllNtReached()
		&& NoCircularProductions()
		&& AllNtToTerm();

	if (ok)
	{
		CheckResolvers(); CheckLL1();
	}
    return ok;
}


//--------------- check for circular productions ----------------------

void Tab::GetSingles(Node *p, ArrayList<Symbol>& singles)
{
	if (p == NULL) return;  // end of graph
	if (p->typ == Node::nt)
	{
		if (p->up || DelGraph(p->next))
			singles.Add(p->sym);
	}
	else if
	(
	    p->typ == Node::alt
	 || p->typ == Node::iter
	 || p->typ == Node::opt
	)
	{
		if (p->up || DelGraph(p->next))
		{
			GetSingles(p->sub, singles);
			if (p->typ == Node::alt)
				GetSingles(p->down, singles);
		}
	}

	if (!p->up && DelNode(p))
		GetSingles(p->next, singles);
}


bool Tab::NoCircularProductions()
{
	ArrayList<CNode> list;

	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		ArrayList<Symbol> singles;
		GetSingles(sym->graph, singles); // get nonterminals s such that sym-->s
		for (int j=0; j < singles.Count; j++)
		{
			Symbol *s = singles[j];
			list.Add(new CNode(sym, s));
		}
	}

	bool changed;
	do
	{
		changed = false;
		for (int i = 0; i < list.Count; i++)
		{
			CNode *n = list[i];
			bool onLeftSide = false;
			bool onRightSide = false;
			for (int j=0; j <list.Count; j++)
			{
				CNode *m = list[j];
				if (n->left == m->right) onRightSide = true;
				if (n->right == m->left) onLeftSide = true;
			}
			if (!onLeftSide || !onRightSide)
			{
				list.Remove(n); i--; changed = true;
			}
		}
	} while (changed);

	bool ok = true;
	for (int i=0; i < list.Count; i++)
	{
		CNode *n = list[i];
		ok = false;
		errors->count++;
		wprintf(L"  %ls --> %ls", n->left->name, n->right->name);
	}
	return ok;
}


//--------------- check for LL(1) errors ----------------------

void Tab::LL1Error(int cond, Symbol *sym)
{
	wprintf(L"  LL1 warning in %ls: ", curSy->name);
	if (sym != NULL) wprintf(L"%ls is ", sym->name);
	switch (cond)
	{
		case 1: wprintf(L"start of several alternatives\n"); break;
		case 2: wprintf(L"start & successor of deletable structure\n"); break;
		case 3: wprintf(L"an ANY node that matches no symbol\n"); break;
		case 4: wprintf(L"contents of [...] or {...} must not be deletable\n"); break;
	}
}


void Tab::CheckOverlap(BitArray *s1, BitArray *s2, int cond)
{
	for (int i=0; i < terminals.Count; i++)
	{
		Symbol *sym = terminals[i];
		if ((*s1)[sym->n] && (*s2)[sym->n])
		{
			LL1Error(cond, sym);
		}
	}
}


void Tab::CheckAlts(Node *p)
{
	BitArray *s1, *s2;
	while (p != NULL)
	{
		if (p->typ == Node::alt)
		{
			Node *q = p;
			s1 = new BitArray(terminals.Count);
			while (q != NULL)  // for all alternatives
			{
				s2 = Expected0(q->sub, curSy);
				CheckOverlap(s1, s2, 1);
				s1->Or(s2);
				CheckAlts(q->sub);
				q = q->down;
			}
		}
		else if (p->typ == Node::opt || p->typ == Node::iter)
		{
			if (DelSubGraph(p->sub))
			{
				LL1Error(4, NULL); // e.g. [[...]]
			}
			else
			{
				s1 = Expected0(p->sub, curSy);
				s2 = Expected(p->next, curSy);
				CheckOverlap(s1, s2, 2);
			}
			CheckAlts(p->sub);
		}
		else if (p->typ == Node::any)
		{
			if (Sets::Elements(p->set) == 0) LL1Error(3, NULL);
			// e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
		}
		if (p->up) break;
		p = p->next;
	}
}


void Tab::CheckLL1()
{
	for (int i=0; i < nonterminals.Count; i++)
	{
		curSy = nonterminals[i];
		CheckAlts(curSy->graph);
	}
}

//------------- check if resolvers are legal  --------------------

void Tab::ResErr(Node *p, const wchar_t* msg)
{
	errors->Warning(p->line, p->pos->col, msg);
}


void Tab::CheckRes(Node *p, bool rslvAllowed)
{
	while (p != NULL)
	{
		Node *q;
		if (p->typ == Node::alt)
		{
			BitArray *expected = new BitArray(terminals.Count);
			for (q = p; q != NULL; q = q->down)
				expected->Or(Expected0(q->sub, curSy));
			BitArray *soFar = new BitArray(terminals.Count);
			for (q = p; q != NULL; q = q->down)
			{
				if (q->sub->typ == Node::rslv)
				{
					BitArray *fs = Expected(q->sub->next, curSy);
					if (Sets::Intersect(fs, soFar))
						ResErr(q->sub, L"Warning: Resolver will never be evaluated. Place it at previous conflicting alternative.");
					if (!Sets::Intersect(fs, expected))
						ResErr(q->sub, L"Warning: Misplaced resolver: no LL(1) conflict.");
				} else soFar->Or(Expected(q->sub, curSy));
				CheckRes(q->sub, true);
			}
		}
		else if (p->typ == Node::iter || p->typ == Node::opt)
		{
			if (p->sub->typ == Node::rslv)
			{
				BitArray *fs = First(p->sub->next);
				BitArray *fsNext = Expected(p->next, curSy);
				if (!Sets::Intersect(fs, fsNext))
					ResErr(p->sub, L"Warning: Misplaced resolver: no LL(1) conflict.");
			}
			CheckRes(p->sub, true);
		}
		else if (p->typ == Node::rslv)
		{
			if (!rslvAllowed)
				ResErr(p, L"Warning: Misplaced resolver: no alternative.");
		}

		if (p->up) break;
		p = p->next;
		rslvAllowed = false;
	}
}


void Tab::CheckResolvers()
{
	for (int i=0; i < nonterminals.Count; i++)
	{
		curSy = nonterminals[i];
		CheckRes(curSy->graph, false);
	}
}


//------------- check if every nts has a production --------------------

bool Tab::NtsComplete()
{
	bool complete = true;
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		if (sym->graph == NULL)
		{
			complete = false; errors->count++;
			wprintf(L"  No production for %ls\n", sym->name);
		}
	}
	return complete;
}


//-------------- check if every nts can be reached  -----------------

void Tab::MarkReachedNts(Node *p)
{
	while (p != NULL)
	{
		if (p->typ == Node::nt && !((*visited)[p->sym->n]))  // new nt reached
		{
			visited->Set(p->sym->n, true);
			MarkReachedNts(p->sym->graph);
		}
		else if
		(
		    p->typ == Node::alt
		 || p->typ == Node::iter
		 || p->typ == Node::opt
		)
		{
			MarkReachedNts(p->sub);
			if (p->typ == Node::alt) MarkReachedNts(p->down);
		}
		if (p->up) break;
		p = p->next;
	}
}


bool Tab::AllNtReached()
{
	bool ok = true;
	visited = new BitArray(nonterminals.Count);
	visited->Set(gramSy->n, true);
	MarkReachedNts(gramSy->graph);
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		if (!((*visited)[sym->n]))
		{
			ok = false;
			errors->count++;
			wprintf(L"  %ls cannot be reached\n", sym->name);
		}
	}
	return ok;
}

//--------- check if every nts can be derived to terminals  ------------

bool Tab::IsTerm(Node *p, BitArray *mark) // true if graph can be derived to terminals
{
	while (p != NULL)
	{
		if (p->typ == Node::nt && !((*mark)[p->sym->n]))
		{
			return false;
		}
		if
		(
		    p->typ == Node::alt
		 && !IsTerm(p->sub, mark)
		 && (p->down == NULL || !IsTerm(p->down, mark))
		)
		{
			return false;
		}

		if (p->up) break;
		p = p->next;
	}
	return true;
}


bool Tab::AllNtToTerm()
{
	BitArray *mark = new BitArray(nonterminals.Count);
	// a nonterminal is marked if it can be derived to terminal symbols

	bool changed;
	do {
		changed = false;

		for (int i=0; i < nonterminals.Count; i++)
		{
			Symbol *sym = nonterminals[i];
			if (!((*mark)[sym->n]) && IsTerm(sym->graph, mark))
			{
				mark->Set(sym->n, true); changed = true;
			}
		}
	} while (changed);

	bool ok = true;
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		if (!((*mark)[sym->n]))
		{
			ok = false;
			errors->count++;
			wprintf(L"  %ls cannot be derived to terminals\n", sym->name);
		}
	}
	return ok;
}


//---------------------------------------------------------------------
//  Cross reference list
//---------------------------------------------------------------------

void Tab::XRef()
{
	SortedList< ArrayList<int> > xref;

	// collect lines where symbols have been defined
	for (int i=0; i < nonterminals.Count; i++)
	{
		Symbol *sym = nonterminals[i];
		ArrayList<int> *list = xref.Get(sym);
		if (list == NULL)
		{
			list = new ArrayList<int>();
			xref.Set(sym, list);
		}
		int *intg = new int(- sym->line);
		list->Add(intg);
	}

	// collect lines where symbols have been referenced
	for (int i=0; i < nodes.Count; i++)
	{
		Node *n = nodes[i];
		if (n->typ == Node::t || n->typ == Node::wt || n->typ == Node::nt)
		{
			ArrayList<int> *list = xref.Get(n->sym);
			if (list == NULL)
			{
				list = new ArrayList<int>();
				xref.Set(n->sym, list);
			}
			int *intg = new int(n->line);
			list->Add(intg);
		}
	}
	// print cross reference list
	fwprintf(trace, L"\n");
	fwprintf(trace, L"Cross reference list:\n");
	fwprintf(trace, L"--------------------\n\n");

	for (int i=0; i < xref.Count; i++)
	{
		Symbol *sym = xref.GetKey(i);
		fwprintf(trace, L"  %-12ls", sym->name);
		ArrayList<int> *list = xref.Get(sym);
		int col = 14;
		for (int j=0; j <list->Count; j++)
		{
			int line = *((*list)[j]);
			if (col + 5 > 80)
			{
				fwprintf(trace, L"\n");
				for (col = 1; col <= 14; col++) fwprintf(trace, L" ");
			}
			fwprintf(trace, L"%5d", line); col += 5;
		}
		fwprintf(trace, L"\n");
	}
	fwprintf(trace, L"\n\n");
}


void Tab::DispatchDirective(const wchar_t* str)
{
	const int len1 = coco_string_indexof(str, '=');
	const int len2 = coco_string_length(str) - len1 - 1;

	if (len1 < 0 || len2 < 1)
	{
		return;
	}
	wchar_t* name = coco_string_create(str, 0, len1);
	const wchar_t* strval = (str + len1+1);

	if (coco_string_equal(name, L"namespace"))
	{
		// set namespace if not already set
		if (nsName.empty())
		{
			nsName = coco_stdStringASCII(strval, 0, len2);
		}
		wprintf(L"using namespace: '%s'\n", nsName.c_str());
	}
	else if (coco_string_equal(name, L"prefix"))
	{
		// set prefix if not already set
		if (prefixName.empty())
		{
			prefixName = coco_stdStringASCII(strval, 0, len2);
		}
		wprintf(L"using prefix: '%s'\n", prefixName.c_str());
	}
	else if (coco_string_equal(name, L"trace"))
	{
		SetDDT(strval);
	}
	else if (coco_string_equal(name, L"explicitEOF"))
	{
		const int boolval = coco_string_checkBool(strval);
		if (boolval > 0)
		{
			Tab::explicitEOF = true;
		}
		else if (!boolval)
		{
			Tab::explicitEOF = false;
		}
		else
		{
			wprintf
			(
				L"ignoring unknown bool value for pragma: '%ls' = '%ls'\n",
				name, strval
			);
		}
	}
	else if (coco_string_equal(name, L"lines"))
	{
		const int boolval = coco_string_checkBool(strval);
		if (boolval > 0)
		{
			emitLines = true;
		}
		else if (!boolval)
		{
			emitLines = false;
		}
		else
		{
			wprintf
			(
				L"ignoring unknown bool value for pragma: '%ls' = '%ls'\n",
				name, strval
			);
		}
	}
	else if (coco_string_equal(name, L"single"))
	{
		const int boolval = coco_string_checkBool(strval);
		if (boolval > 0)
		{
			singleOutput = true;
		}
		else if (!boolval)
		{
			singleOutput = false;
		}
		else
		{
			wprintf
			(
				L"ignoring unknown bool value for pragma: '%ls' = '%ls'\n",
				name, strval
			);
		}
	}
	else
	{
		wprintf(L"ignoring unknown pragma: '%ls'\n", name);
	}

	coco_string_delete(name);
}


void Tab::SetDDT(const wchar_t* str)
{
	const int len = (str && *str) ? coco_string_length(str) : 0;

	for (int i = 0; i < len; i++)
	{
		char ch = str[i];
		if (ch >= '0' && ch <= '9')
		{
			ddt[ch - '0'] = true;
		}
		else
		{
			switch (ch)
			{
			 case 'A': case 'a': ddt[0] = true; break; // trace automaton
			 case 'F': case 'f': ddt[1] = true; break; // list first/follow sets
			 case 'G': case 'g': ddt[2] = true; break; // print syntax graph
			 case 'I': case 'i': ddt[3] = true; break; // trace computation of first sets
			 case 'J': case 'j': ddt[4] = true; break; // print ANY and SYNC sets
			 case 'P': case 'p': ddt[8] = true; break; // print statistics
			 case 'S': case 's': ddt[6] = true; break; // list symbol table
			 case 'X': case 'x': ddt[7] = true; break; // list cross reference table
			 default: break;
			}
		}
	}
}


// * * * * * * * * * * * * *  Misc Output Methods  * * * * * * * * * * * * * //

//
// reduce multiple '::' -> ':', skip initial ':'
//
int Tab::GenNamespaceOpen(FILE* ostr) const
{
	const std::string::size_type len = nsName.size();

	if (!nsName.size())
	{
		return 0;
	}

	int nrOfNs = 0;
	for (std::string::size_type startPos = 0; startPos < len; ++startPos)
	{
		// skip leading and multiple ':'
		while (nsName[startPos] == ':')
		{
			++startPos;
		}

		std::string::size_type curLen = nsName.find(':', startPos);
		if (curLen == std::string::npos)
		{
			curLen = len;
		}
		curLen -= startPos;

		if (curLen)
		{
			fwprintf
			(
				ostr, L"namespace %s {\n",
				nsName.substr(startPos, curLen).c_str()
			);
			++nrOfNs;
		}
		startPos += curLen;
	}

	return nrOfNs;
}


void Tab::GenNamespaceClose(FILE* ostr, int nrOfNs)
{
	for (int i = 0; i < nrOfNs; ++i)
	{
		fwprintf(ostr, L"} // End namespace\n");
	}
}


FILE* Tab::OpenFrameFile(const std::string& frameName) const
{
	FILE* istr = NULL;

#ifdef _WIN32
	// On windows systems, wmain() passes 16bit unicode wide characters
	// from the command-line. Use the corresponding wide file open/close
	// routines
	std::wstring fullName;

	// 1: look in specified frameDir
	if (!frameDir.empty())
	{
		fullName = frameDir;
		fullName += coco_stdWString(frameName);

		if ((istr = _wfopen(fullName.c_str(), L"r")) != NULL)
		{
			return istr;
		}
	}

	// 2: look in local directory
	fullName = coco_stdWString(frameName);
	if ((istr = _wfopen(fullName.c_str(), L"r")) != NULL)
	{
		return istr;
	}

	// 3: look in srcDir
	fullName = srcDir;
	fullName += coco_stdWString(frameName);

	if ((istr = _wfopen(fullName.c_str(), L"r")) != NULL)
	{
		return istr;
	}
#else
	// Other systems simply maintain the same character encoding
	// as the operating system (often UTF8)
	std::string fullName;

	// 1: look in specified frameDir
	if (!frameDir.empty())
	{
		fullName = frameDir;
		fullName += frameName;

		if ((istr = fopen(fullName.c_str(), "r")) != NULL)
		{
			return istr;
		}
	}

	// 2: look in local directory
	fullName = frameName;
	if ((istr = fopen(fullName.c_str(), "r")) != NULL)
	{
		return istr;
	}

	// 3: look in srcDir
	fullName = srcDir;
	fullName += frameName;

	if ((istr = fopen(fullName.c_str(), "r")) != NULL)
	{
		return istr;
	}
#endif

	return istr;
}


FILE* Tab::OpenGenFile(const std::string& genName) const
{
	FILE* ostr = NULL;
#ifdef _WIN32
	std::wstring fullName = outDir;
	if (prefixName.size())
	{
		fullName += coco_stdWString(prefixName);
	}
	fullName += coco_stdWString(genName);

	if
	(
	    makeBackup
	 && ((ostr = _wfopen(fullName.c_str(), L"r")) != NULL)
	)
	{
		fclose(ostr);
		std::wstring bakName = fullName + L".bak";
		_wremove(bakName.c_str());
		_wrename(fullName.c_str(), bakName.c_str()); // copy with overwrite
	}

	ostr = _wfopen(fullName.c_str(), L"w");

#else
	std::string fullName = outDir;
	if (prefixName.size())
	{
		fullName += prefixName;
	}
	fullName += genName;

	if
	(
	    makeBackup
	 && ((ostr = fopen(fullName.c_str(), "r")) != NULL)
	)
	{
		fclose(ostr);
		std::string bakName = fullName + ".bak";
		remove(bakName.c_str());
		rename(fullName.c_str(), bakName.c_str()); // copy with overwrite
	}

	ostr = fopen(fullName.c_str(), "w");
#endif

	return ostr;
}


bool Tab::CopyFramePart
(
	FILE* ostr,
	FILE* istr,
	const wchar_t* stop,
	const bool doOutput
) const
{
	wchar_t startCh = stop[0];
	int endOfStopString = coco_string_length(stop)-1;

	int endOfPrefixMacro = coco_string_length(Tab::prefixMacro)-1;
	wchar_t startPrefixCh = Tab::prefixMacro[0];
	const bool isPrefixSet = !prefixName.empty();

	wchar_t ch = 0;
	fwscanf(istr, L"%lc", &ch); //	istr.ReadByte();
	while (!feof(istr)) // ch != EOF
	{
		if (ch == startCh)
		{
			int i = 0;
			do {
				if (i == endOfStopString)
					return true; // stop[0..i] found
				fwscanf(istr, L"%lc", &ch);
				i++;
			} while (ch == stop[i]);
			// stop[0..i-1] found; continue with last read character
			if (doOutput)
			{
				for (int subI = 0; subI < i; ++subI)
				{
					fwprintf(ostr, L"%lc", stop[subI]);
				}
			}
		}
		else if (ch == startPrefixCh)
		{
			bool found = false;
			int i = 0;
			do {
				if (i == endOfPrefixMacro)
				{
					found = true;
					break;
				}
				fwscanf(istr, L"%lc", &ch);
				i++;
			} while (ch == Tab::prefixMacro[i]);
			// prefixMacro[0..i-1] found; continue with last read character
			if (found)
			{
				if (doOutput && isPrefixSet)
				{
					fwprintf(ostr, L"%s", prefixName.c_str());
				}
				fwscanf(istr, L"%lc", &ch);
			}
			else
			{
				if (doOutput)
				{
					for (int subI = 0; subI < i; ++subI)
					{
						fwprintf(ostr, L"%lc", Tab::prefixMacro[subI]);
					}
				}
			}
		}
		else
		{
			if (doOutput)
			{
				fwprintf(ostr, L"%lc", ch);
			}
			fwscanf(istr, L"%lc", &ch);
		}
	}

	return false; // error
}


void Tab::CopySourcePart(FILE *dest, Position *pos, int indent, bool emitLines)
{
	// Copy text described by pos from atg to dest
	int ch, i;
	if (pos != NULL)
	{
		buffer->SetPos(pos->beg); ch = buffer->Read();
		if (emitLines && pos->line)
		{
#ifdef _WIN32
			fwprintf(dest, L"\n#line %d \"%ls\"\n", pos->line, srcName.c_str());
#else
			fwprintf(dest, L"\n#line %d \"%s\"\n", pos->line, srcName.c_str());
#endif
		}
		for (int t=0; t < indent; ++t) fwprintf(dest, L"\t");
		while (buffer->GetPos() <= pos->end)
		{
			while (ch == CR || ch == LF)   // eol is either CR or CRLF or LF
			{
				fwprintf(dest, L"\n");
				for (int t=0; t < indent; ++t) fwprintf(dest, L"\t");
				if (ch == CR) { ch = buffer->Read(); } // skip CR
				if (ch == LF) { ch = buffer->Read(); } // skip LF
				for (i = 1; i <= pos->col && (ch == ' ' || ch == '\t'); i++)
				{
					// skip blanks at beginning of line
					ch = buffer->Read();
				}
				if (i <= pos->col) pos->col = i - 1; // heading TABs => not enough blanks
				if (buffer->GetPos() > pos->end) goto Done;
			}
			fwprintf(dest, L"%lc", ch);
			ch = buffer->Read();
		}
		Done:
		if (indent > 0) fwprintf(dest, L"\n");
	}
}



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Coco

// ************************************************************************* //
