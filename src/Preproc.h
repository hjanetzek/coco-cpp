/*---------------------------------*- C++ -*---------------------------------*\
  Compiler Generator Coco/R
  Copyright (C) 2010 Mark Olesen
-------------------------------------------------------------------------------
License
    This file is part of Compiler Generator Coco/R

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

Class
    Coco::Preproc

Description
    A simple pre-processor class

SourceFiles
    header only

\*---------------------------------------------------------------------------*/

#ifndef COCO_PREPROC_H__
#define COCO_PREPROC_H__

#include <set>
#include <sstream>
#include <string>

namespace Coco
{

/*---------------------------------------------------------------------------*\
                           Class Preproc Declaration
\*---------------------------------------------------------------------------*/

/*! @brief A simple Pre-Processor
 * Handles the following directives:
 * - \$ifdef NAME
 * - \$ifndef NAME
 * - \$else
 * - \$endif
 */
class Preproc
{
    int curr_;    //!< current logic level
    int prev_;    //!< previous logic level
    int exec_;    //!< logic level at which we should exec

    std::set<std::string> defines_;

    inline bool ifdef(const std::string& name) const
    {
        return defines_.find(name) != defines_.end();
    }

public:

    //! Construct null or with predefines
    Preproc(const std::string& defs = std::string())
    :
        curr_(0),
        prev_(0),
        exec_(0)
    {
        define(defs);
    }


    //! Add name to defines - split automatically on whitespace
    void define(const std::string& defs)
    {
        std::istringstream sbuf(defs);
        std::string tok;

        while (sbuf >> tok)
        {
            defines_.insert(tok);
        }
    }


    //! Remove name from defines - split automatically on whitespace
    inline void undef(const std::string& defs)
    {
        std::istringstream sbuf(defs);
        std::string tok;

        while (sbuf >> tok)
        {
            defines_.erase(tok);
        }
    }


    //! Return the current output state
    inline bool state() const
    {
        return curr_ == exec_;
    }


    //! Reset all the defines
    inline void clear()
    {
        return defines_.clear();
    }


    //! Reset the logic for reuse
    inline void reset()
    {
        curr_ = prev_ = exec_ = 0;
    }


    // check the line and return true for output
    bool okay(const std::string& line)
    {
        // check the line for initial '$directive'

        // no '$' introducer
        if (line.find('$') == std::string::npos)
        {
            return state();
        }

        std::istringstream sbuf(line);

        // only allow leading space
        std::string tok;
        sbuf >> tok;

        if (tok == "$ifdef" || tok == "$ifndef")
        {
            const bool normal = (tok.find('n') == std::string::npos);

            std::string name;
            sbuf >> name;

            if (name.empty())
            {
                std::cerr << "missing name on directive " << tok << "\n";
            }
            else
            {
                if (curr_++ == exec_)
                {
                    if (normal ? ifdef(name) : !ifdef(name))
                    {
                        exec_ = prev_ = curr_;
                    }
                }
            }
        }
        else if (tok == "$else")
        {
            if ((curr_ == exec_+1) && curr_ != prev_)
            {
                exec_ = curr_;   // in position to execute
            }
            else if (curr_ == exec_)
            {
                exec_--;         // still nested too many levels
            }
        }
        else if (tok == "$endif")
        {
            if (curr_ == exec_)
            {
                exec_--;
                prev_ = exec_;   // pull down prev as well
            }

            curr_--;
            if (prev_ > curr_)
            {
                prev_ = curr_;
            }

        }
        else
        {
            if (tok[0] == '$')
            {
                std::cerr<< "unknown/unsupported directive " << tok << "\n";
            }
            return state();
        }


        return false;           // never output directive lines
    }

};


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //


} // End namespace Coco

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#endif

// ************************************************************************* //
